// Generated by CoffeeScript 1.8.0
(function() {
  var _base, _base1, _base2, _base3;

  if (window.Epoch == null) {
    window.Epoch = {};
  }

  if ((_base = window.Epoch).Chart == null) {
    _base.Chart = {};
  }

  if ((_base1 = window.Epoch).Time == null) {
    _base1.Time = {};
  }

  if ((_base2 = window.Epoch).Util == null) {
    _base2.Util = {};
  }

  if ((_base3 = window.Epoch).Formats == null) {
    _base3.Formats = {};
  }

  Epoch.warn = function(msg) {
    return (console.warn || console.log)("Epoch Warning: " + msg);
  };

  Epoch.exception = function(msg) {
    throw "Epoch Error: " + msg;
  };

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  Epoch.TestContext = (function() {
    var VOID_METHODS;

    VOID_METHODS = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'drawImage', 'fill', 'fillRect', 'fillText', 'moveTo', 'quadraticCurveTo', 'rect', 'restore', 'rotate', 'save', 'scale', 'scrollPathIntoView', 'setLineDash', 'setTransform', 'stroke', 'strokeRect', 'strokeText', 'transform', 'translate'];

    function TestContext() {
      var method, _i, _len;
      this._log = [];
      for (_i = 0, _len = VOID_METHODS.length; _i < _len; _i++) {
        method = VOID_METHODS[_i];
        this._makeFauxMethod(method);
      }
    }

    TestContext.prototype._makeFauxMethod = function(name) {
      return this[name] = function() {
        var arg;
        return this._log.push("" + name + "(" + (((function() {
          var _i, _len, _results;
          _results = [];
          for (_i = 0, _len = arguments.length; _i < _len; _i++) {
            arg = arguments[_i];
            _results.push(arg.toString());
          }
          return _results;
        }).apply(this, arguments)).join(',')) + ")");
      };
    };

    TestContext.prototype.getImageData = function() {
      var arg;
      this._log.push("getImageData(" + (((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arguments.length; _i < _len; _i++) {
          arg = arguments[_i];
          _results.push(arg.toString());
        }
        return _results;
      }).apply(this, arguments)).join(',')) + ")");
      return {
        width: 0,
        height: 0,
        resolution: 1.0,
        data: []
      };
    };

    return TestContext;

  })();

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var typeFunction, _ref;

  typeFunction = function(objectName) {
    return function(v) {
      return Object.prototype.toString.call(v) === ("[object " + objectName + "]");
    };
  };

  Epoch.isArray = (_ref = Array.isArray) != null ? _ref : typeFunction('Array');

  Epoch.isObject = typeFunction('Object');

  Epoch.isString = typeFunction('String');

  Epoch.isFunction = typeFunction('Function');

  Epoch.isNumber = typeFunction('Number');

  Epoch.isElement = function(v) {
    if (typeof HTMLElement !== "undefined" && HTMLElement !== null) {
      return v instanceof HTMLElement;
    } else {
      return (v != null) && Epoch.isObject(v) && v.nodeType === 1 && Epoch.isString(v.nodeName);
    }
  };

  Epoch.Util.copy = function(original) {
    var copy, k, v;
    if (original == null) {
      return null;
    }
    copy = {};
    for (k in original) {
      v = original[k];
      copy[k] = v;
    }
    return copy;
  };

  Epoch.Util.defaults = function(options, defaults) {
    var bothAreObjects, def, k, opt, result, v;
    result = Epoch.Util.copy(options);
    for (k in defaults) {
      v = defaults[k];
      opt = options[k];
      def = defaults[k];
      bothAreObjects = Epoch.isObject(opt) && Epoch.isObject(def);
      if ((opt != null) && (def != null)) {
        if (bothAreObjects && !Epoch.isArray(opt)) {
          result[k] = Epoch.Util.defaults(opt, def);
        } else {
          result[k] = opt;
        }
      } else if (opt != null) {
        result[k] = opt;
      } else {
        result[k] = def;
      }
    }
    return result;
  };

  Epoch.Util.formatSI = function(v, fixed, fixIntegers) {
    var base, i, label, q, _ref1;
    if (fixed == null) {
      fixed = 1;
    }
    if (fixIntegers == null) {
      fixIntegers = false;
    }
    if (v < 1000) {
      q = v;
      if (!((q | 0) === q && !fixIntegers)) {
        q = q.toFixed(fixed);
      }
      return q;
    }
    _ref1 = ['K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
    for (i in _ref1) {
      label = _ref1[i];
      base = Math.pow(10, ((i | 0) + 1) * 3);
      if (v >= base && v < Math.pow(10, ((i | 0) + 2) * 3)) {
        q = v / base;
        if (!((q % 1) === 0 && !fixIntegers)) {
          q = q.toFixed(fixed);
        }
        return "" + q + " " + label;
      }
    }
  };

  Epoch.Util.formatBytes = function(v, fixed, fix_integers) {
    var base, i, label, q, _ref1;
    if (fixed == null) {
      fixed = 1;
    }
    if (fix_integers == null) {
      fix_integers = false;
    }
    if (v < 1024) {
      q = v;
      if (!((q % 1) === 0 && !fix_integers)) {
        q = q.toFixed(fixed);
      }
      return "" + q + " B";
    }
    _ref1 = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    for (i in _ref1) {
      label = _ref1[i];
      base = Math.pow(1024, (i | 0) + 1);
      if (v >= base && v < Math.pow(1024, (i | 0) + 2)) {
        q = v / base;
        if (!((q % 1) === 0 && !fix_integers)) {
          q = q.toFixed(fixed);
        }
        return "" + q + " " + label;
      }
    }
  };

  Epoch.Util.dasherize = function(str) {
    return Epoch.Util.trim(str).replace("\n", '').replace(/\s+/g, '-').toLowerCase();
  };

  Epoch.Util.domain = function(layers, key) {
    var domain, entry, layer, set, _i, _j, _len, _len1, _ref1;
    if (key == null) {
      key = 'x';
    }
    set = {};
    domain = [];
    for (_i = 0, _len = layers.length; _i < _len; _i++) {
      layer = layers[_i];
      _ref1 = layer.values;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        entry = _ref1[_j];
        if (set[entry[key]] != null) {
          continue;
        }
        domain.push(entry[key]);
        set[entry[key]] = true;
      }
    }
    return domain;
  };

  Epoch.Util.trim = function(string) {
    if (!Epoch.isString(string)) {
      return null;
    }
    return string.replace(/^\s+/g, '').replace(/\s+$/g, '');
  };

  Epoch.Util.getComputedStyle = function(element, pseudoElement) {
    if (Epoch.isFunction(window.getComputedStyle)) {
      return window.getComputedStyle(element, pseudoElement);
    } else if (element.currentStyle != null) {
      return element.currentStyle;
    }
  };

  Epoch.Util.toRGBA = function(color, opacity) {
    var all, b, g, parts, r, result, v;
    if ((parts = color.match(/^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*[0-9\.]+\)/))) {
      all = parts[0], r = parts[1], g = parts[2], b = parts[3];
      result = "rgba(" + r + "," + g + "," + b + "," + opacity + ")";
    } else if ((v = d3.rgb(color))) {
      result = "rgba(" + v.r + "," + v.g + "," + v.b + "," + opacity + ")";
    }
    return result;
  };

  Epoch.Util.getContext = function(node, type) {
    if (type == null) {
      type = '2d';
    }
    if (node.getContext != null) {
      return node.getContext(type);
    }
    return new Epoch.TestContext();
  };

  Epoch.Events = (function() {
    function Events() {
      this._events = {};
    }

    Events.prototype.on = function(name, callback) {
      var _base;
      if (callback == null) {
        return;
      }
      if ((_base = this._events)[name] == null) {
        _base[name] = [];
      }
      return this._events[name].push(callback);
    };

    Events.prototype.onAll = function(map) {
      var callback, name, _results;
      if (!Epoch.isObject(map)) {
        return;
      }
      _results = [];
      for (name in map) {
        callback = map[name];
        _results.push(this.on(name, callback));
      }
      return _results;
    };

    Events.prototype.off = function(name, callback) {
      var i, _results;
      if (!Epoch.isArray(this._events[name])) {
        return;
      }
      if (callback == null) {
        return delete this._events[name];
      }
      _results = [];
      while ((i = this._events[name].indexOf(callback)) >= 0) {
        _results.push(this._events[name].splice(i, 1));
      }
      return _results;
    };

    Events.prototype.offAll = function(mapOrList) {
      var callback, name, _i, _len, _results, _results1;
      if (Epoch.isArray(mapOrList)) {
        _results = [];
        for (_i = 0, _len = mapOrList.length; _i < _len; _i++) {
          name = mapOrList[_i];
          _results.push(this.off(name));
        }
        return _results;
      } else if (Epoch.isObject(mapOrList)) {
        _results1 = [];
        for (name in mapOrList) {
          callback = mapOrList[name];
          _results1.push(this.off(name, callback));
        }
        return _results1;
      }
    };

    Events.prototype.trigger = function(name) {
      var args, callback, fn, i, _i, _len, _ref1, _results;
      if (this._events[name] == null) {
        return;
      }
      args = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 1, _ref1 = arguments.length; 1 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 1 <= _ref1 ? ++_i : --_i) {
          _results.push(arguments[i]);
        }
        return _results;
      }).apply(this, arguments);
      _ref1 = this._events[name];
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        callback = _ref1[_i];
        fn = null;
        if (Epoch.isString(callback)) {
          fn = this[callback];
        } else if (Epoch.isFunction(callback)) {
          fn = callback;
        }
        if (fn == null) {
          Epoch.exception("Callback for event '" + name + "' is not a function or reference to a method.");
        }
        _results.push(fn.apply(this, args));
      }
      return _results;
    };

    return Events;

  })();

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  d3.selection.prototype.width = function(value) {
    if ((value != null) && Epoch.isString(value)) {
      return this.style('width', value);
    } else if ((value != null) && Epoch.isNumber(value)) {
      return this.style('width', "" + value + "px");
    } else {
      return +Epoch.Util.getComputedStyle(this.node(), null).width.replace('px', '');
    }
  };

  d3.selection.prototype.height = function(value) {
    if ((value != null) && Epoch.isString(value)) {
      return this.style('height', value);
    } else if ((value != null) && Epoch.isNumber(value)) {
      return this.style('height', "" + value + "px");
    } else {
      return +Epoch.Util.getComputedStyle(this.node(), null).height.replace('px', '');
    }
  };

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var d3Seconds;

  Epoch.Formats.regular = function(d) {
    return d;
  };

  Epoch.Formats.si = function(d) {
    return Epoch.Util.formatSI(d);
  };

  Epoch.Formats.percent = function(d) {
    return (d * 100).toFixed(1) + "%";
  };

  Epoch.Formats.seconds = function(t) {
    return d3Seconds(new Date(t * 1000));
  };

  d3Seconds = d3.time.format('%I:%M:%S %p');

  Epoch.Formats.bytes = function(d) {
    return Epoch.Util.formatBytes(d);
  };

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Base = (function(_super) {
    var defaults, optionListeners;

    __extends(Base, _super);

    defaults = {
      width: 320,
      height: 240,
      dataFormat: null
    };

    optionListeners = {
      'option:width': 'dimensionsChanged',
      'option:height': 'dimensionsChanged',
      'layer:shown': 'layerChanged',
      'layer:hidden': 'layerChanged'
    };

    function Base(options) {
      this.options = options != null ? options : {};
      Base.__super__.constructor.call(this);
      if (this.options.model) {
        if (this.options.model.hasData() != null) {
          this.setData(this.options.model.getData(this.options.type, this.options.dataFormat));
        } else {
          this.setData(this.options.data || []);
        }
        this.options.model.on('data:updated', (function(_this) {
          return function() {
            return _this.setDataFromModel();
          };
        })(this));
      } else {
        this.setData(this.options.data || []);
      }
      if (this.options.el != null) {
        this.el = d3.select(this.options.el);
      }
      this.width = this.options.width;
      this.height = this.options.height;
      if (this.el != null) {
        if (this.width == null) {
          this.width = this.el.width();
        }
        if (this.height == null) {
          this.height = this.el.height();
        }
      } else {
        if (this.width == null) {
          this.width = defaults.width;
        }
        if (this.height == null) {
          this.height = defaults.height;
        }
        this.el = d3.select(document.createElement('DIV')).attr('width', this.width).attr('height', this.height);
      }
      this.onAll(optionListeners);
    }

    Base.prototype._getAllOptions = function() {
      return Epoch.Util.defaults({}, this.options);
    };

    Base.prototype._getOption = function(key) {
      var parts, scope, subkey;
      parts = key.split('.');
      scope = this.options;
      while (parts.length && (scope != null)) {
        subkey = parts.shift();
        scope = scope[subkey];
      }
      return scope;
    };

    Base.prototype._setOption = function(key, value) {
      var parts, scope, subkey;
      parts = key.split('.');
      scope = this.options;
      while (parts.length) {
        subkey = parts.shift();
        if (parts.length === 0) {
          scope[subkey] = arguments[1];
          this.trigger("option:" + arguments[0]);
          return;
        }
        if (scope[subkey] == null) {
          scope[subkey] = {};
        }
        scope = scope[subkey];
      }
    };

    Base.prototype._setManyOptions = function(options, prefix) {
      var key, value, _results;
      if (prefix == null) {
        prefix = '';
      }
      _results = [];
      for (key in options) {
        value = options[key];
        if (Epoch.isObject(value)) {
          _results.push(this._setManyOptions(value, "" + (prefix + key) + "."));
        } else {
          _results.push(this._setOption(prefix + key, value));
        }
      }
      return _results;
    };

    Base.prototype.option = function() {
      if (arguments.length === 0) {
        return this._getAllOptions();
      } else if (arguments.length === 1 && Epoch.isString(arguments[0])) {
        return this._getOption(arguments[0]);
      } else if (arguments.length === 2 && Epoch.isString(arguments[0])) {
        return this._setOption(arguments[0], arguments[1]);
      } else if (arguments.length === 1 && Epoch.isObject(arguments[0])) {
        return this._setManyOptions(arguments[0]);
      }
    };

    Base.prototype.setDataFromModel = function() {
      var prepared;
      prepared = this._prepareData(this.options.model.getData(this.options.type, this.options.dataFormat));
      this.data = this._annotateLayers(prepared);
      return this.draw();
    };

    Base.prototype.setData = function(data, options) {
      var prepared;
      if (options == null) {
        options = {};
      }
      prepared = this._prepareData((this.rawData = this._formatData(data)));
      return this.data = this._annotateLayers(prepared);
    };

    Base.prototype._prepareData = function(data) {
      return data;
    };

    Base.prototype._formatData = function(data) {
      return Epoch.Data.formatData(data, this.options.type, this.options.dataFormat);
    };

    Base.prototype._annotateLayers = function(data) {
      var category, classes, layer, _i, _len;
      category = 1;
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        layer = data[_i];
        classes = ['layer'];
        classes.push("category" + category);
        layer.category = category;
        layer.visible = true;
        if (layer.label != null) {
          classes.push(Epoch.Util.dasherize(layer.label));
        }
        layer.className = classes.join(' ');
        category++;
      }
      return data;
    };

    Base.prototype._findLayer = function(labelOrIndex) {
      var index, l, layer, _i, _len, _ref;
      layer = null;
      if (Epoch.isString(labelOrIndex)) {
        _ref = this.data;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          l = _ref[_i];
          if (l.label === labelOrIndex) {
            layer = l;
            break;
          }
        }
      } else if (Epoch.isNumber(labelOrIndex)) {
        index = parseInt(labelOrIndex);
        if (!(index < 0 || index >= this.data.length)) {
          layer = this.data[index];
        }
      }
      return layer;
    };

    Base.prototype.showLayer = function(labelOrIndex) {
      var layer;
      if (!(layer = this._findLayer(labelOrIndex))) {
        return;
      }
      if (layer.visible) {
        return;
      }
      layer.visible = true;
      return this.trigger('layer:shown');
    };

    Base.prototype.hideLayer = function(labelOrIndex) {
      var layer;
      if (!(layer = this._findLayer(labelOrIndex))) {
        return;
      }
      if (!layer.visible) {
        return;
      }
      layer.visible = false;
      return this.trigger('layer:hidden');
    };

    Base.prototype.toggleLayer = function(labelOrIndex) {
      var layer;
      if (!(layer = this._findLayer(labelOrIndex))) {
        return;
      }
      layer.visible = !layer.visible;
      if (layer.visible) {
        return this.trigger('layer:shown');
      } else {
        return this.trigger('layer:hidden');
      }
    };

    Base.prototype.isLayerVisible = function(labelOrIndex) {
      var layer;
      if (!(layer = this._findLayer(labelOrIndex))) {
        return null;
      }
      return layer.visible;
    };

    Base.prototype.getVisibleLayers = function() {
      var layer, visible, _i, _len, _ref;
      visible = [];
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (layer.visible) {
          visible.push(layer);
        }
      }
      return visible;
    };

    Base.prototype.update = function(data, draw) {
      if (draw == null) {
        draw = true;
      }
      this.setData(data);
      if (draw) {
        return this.draw();
      }
    };

    Base.prototype.draw = function() {
      return this.trigger('draw');
    };

    Base.prototype.extent = function(cmp) {
      return [
        d3.min(this.getVisibleLayers(), function(layer) {
          return d3.min(layer.values, cmp);
        }), d3.max(this.getVisibleLayers(), function(layer) {
          return d3.max(layer.values, cmp);
        })
      ];
    };

    Base.prototype.dimensionsChanged = function() {
      this.width = this.option('width') || this.width;
      this.height = this.option('height') || this.height;
      this.el.width(this.width);
      return this.el.height(this.height);
    };

    Base.prototype.layerChanged = function() {
      return this.draw();
    };

    return Base;

  })(Epoch.Events);

  Epoch.Chart.SVG = (function(_super) {
    __extends(SVG, _super);

    function SVG(options) {
      this.options = options != null ? options : {};
      SVG.__super__.constructor.call(this, this.options);
      if (this.el != null) {
        this.svg = this.el.append('svg');
      } else {
        this.svg = d3.select(document.createElement('svg'));
      }
      this.svg.attr({
        xmlns: 'http://www.w3.org/2000/svg',
        width: this.width,
        height: this.height
      });
    }

    SVG.prototype.dimensionsChanged = function() {
      SVG.__super__.dimensionsChanged.call(this);
      return this.svg.attr('width', this.width).attr('height', this.height);
    };

    return SVG;

  })(Epoch.Chart.Base);

  Epoch.Chart.Canvas = (function(_super) {
    __extends(Canvas, _super);

    function Canvas(options) {
      this.options = options != null ? options : {};
      Canvas.__super__.constructor.call(this, this.options);
      if (this.options.pixelRatio != null) {
        this.pixelRatio = this.options.pixelRatio;
      } else if (window.devicePixelRatio != null) {
        this.pixelRatio = window.devicePixelRatio;
      } else {
        this.pixelRatio = 1;
      }
      this.canvas = d3.select(document.createElement('CANVAS'));
      this.canvas.style({
        'width': "" + this.width + "px",
        'height': "" + this.height + "px"
      });
      this.canvas.attr({
        width: this.getWidth(),
        height: this.getHeight()
      });
      if (this.el != null) {
        this.el.node().appendChild(this.canvas.node());
      }
      this.ctx = Epoch.Util.getContext(this.canvas.node());
    }

    Canvas.prototype.getWidth = function() {
      return this.width * this.pixelRatio;
    };

    Canvas.prototype.getHeight = function() {
      return this.height * this.pixelRatio;
    };

    Canvas.prototype.clear = function() {
      return this.ctx.clearRect(0, 0, this.getWidth(), this.getHeight());
    };

    Canvas.prototype.getStyles = function(selector) {
      return Epoch.QueryCSS.getStyles(selector, this.el);
    };

    Canvas.prototype.dimensionsChanged = function() {
      Canvas.__super__.dimensionsChanged.call(this);
      this.canvas.style({
        'width': "" + this.width + "px",
        'height': "" + this.height + "px"
      });
      return this.canvas.attr({
        width: this.getWidth(),
        height: this.getHeight()
      });
    };

    return Canvas;

  })(Epoch.Chart.Base);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var QueryCSS;

  QueryCSS = (function() {
    var CONTAINER_HASH_ATTR, PUT_EXPR, REFERENCE_CONTAINER_ID, containerCount, logging, nextContainerId, put;

    function QueryCSS() {}

    REFERENCE_CONTAINER_ID = '_canvas_css_reference';

    CONTAINER_HASH_ATTR = 'data-epoch-container-id';

    containerCount = 0;

    nextContainerId = function() {
      return "epoch-container-" + (containerCount++);
    };

    PUT_EXPR = /^([^#. ]+)?(#[^. ]+)?(\.[^# ]+)?$/;

    logging = false;

    put = function(selector) {
      var classNames, element, id, match, tag, whole;
      match = selector.match(PUT_EXPR);
      if (match == null) {
        return Epoch.error('Query CSS cannot match given selector: ' + selector);
      }
      whole = match[0], tag = match[1], id = match[2], classNames = match[3];
      tag = (tag != null ? tag : 'div').toUpperCase();
      element = document.createElement(tag);
      if (id != null) {
        element.id = id.substr(1);
      }
      if (classNames != null) {
        element.className = classNames.substr(1).replace(/\./g, ' ');
      }
      return element;
    };

    QueryCSS.log = function(b) {
      return logging = b;
    };

    QueryCSS.cache = {};

    QueryCSS.styleList = ['fill', 'stroke', 'stroke-width'];

    QueryCSS.container = null;

    QueryCSS.purge = function() {
      return QueryCSS.cache = {};
    };

    QueryCSS.getContainer = function() {
      var container;
      if (QueryCSS.container != null) {
        return QueryCSS.container;
      }
      container = document.createElement('DIV');
      container.id = REFERENCE_CONTAINER_ID;
      document.body.appendChild(container);
      return QueryCSS.container = d3.select(container);
    };

    QueryCSS.hash = function(selector, container) {
      var containerId;
      containerId = container.attr(CONTAINER_HASH_ATTR);
      if (containerId == null) {
        containerId = nextContainerId();
        container.attr(CONTAINER_HASH_ATTR, containerId);
      }
      return "" + containerId + "__" + selector;
    };

    QueryCSS.getStyles = function(selector, container) {
      var cache, cacheKey, el, element, name, parent, parentNode, parents, ref, root, sel, selectorList, styles, subSelector, _i, _j, _k, _len, _len1, _len2, _ref, _ref1;
      cacheKey = QueryCSS.hash(selector, container);
      cache = QueryCSS.cache[cacheKey];
      if (cache != null) {
        return cache;
      }
      parents = [];
      parentNode = container.node().parentNode;
      while ((parentNode != null) && parentNode.nodeName.toLowerCase() !== 'body') {
        parents.unshift(parentNode);
        parentNode = parentNode.parentNode;
      }
      parents.push(container.node());
      selectorList = [];
      for (_i = 0, _len = parents.length; _i < _len; _i++) {
        element = parents[_i];
        sel = element.nodeName.toLowerCase();
        if ((element.id != null) && element.id.length > 0) {
          sel += '#' + element.id;
        }
        if ((element.className != null) && element.className.length > 0) {
          sel += '.' + Epoch.Util.trim(element.className).replace(/\s+/g, '.');
        }
        selectorList.push(sel);
      }
      selectorList.push('svg');
      _ref = Epoch.Util.trim(selector).split(/\s+/);
      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
        subSelector = _ref[_j];
        selectorList.push(subSelector);
      }
      if (logging) {
        console.log(selectorList);
      }
      parent = root = put(selectorList.shift());
      while (selectorList.length) {
        el = put(selectorList.shift());
        parent.appendChild(el);
        parent = el;
      }
      if (logging) {
        console.log(root);
      }
      QueryCSS.getContainer().node().appendChild(root);
      ref = d3.select('#' + REFERENCE_CONTAINER_ID + ' ' + selector);
      styles = {};
      _ref1 = QueryCSS.styleList;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        name = _ref1[_k];
        styles[name] = ref.style(name);
      }
      QueryCSS.cache[cacheKey] = styles;
      QueryCSS.getContainer().html('');
      return styles;
    };

    return QueryCSS;

  })();

  Epoch.QueryCSS = QueryCSS;

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var applyLayerLabel, _base,
    __slice = [].slice;

  if (Epoch.Data == null) {
    Epoch.Data = {};
  }

  if ((_base = Epoch.Data).Format == null) {
    _base.Format = {};
  }

  applyLayerLabel = function(layer, options, i, keys) {
    var autoLabels, keyLabels, label, labels, _ref;
    if (keys == null) {
      keys = [];
    }
    _ref = [options.labels, options.autoLabels, options.keyLabels], labels = _ref[0], autoLabels = _ref[1], keyLabels = _ref[2];
    if ((labels != null) && Epoch.isArray(labels) && labels.length > i) {
      layer.label = labels[i];
    } else if (keyLabels && keys.length > i) {
      layer.label = keys[i];
    } else if (autoLabels) {
      label = [];
      while (i >= 0) {
        label.push(String.fromCharCode(65 + (i % 26)));
        i -= 26;
      }
      layer.label = label.join('');
    }
    return layer;
  };

  Epoch.Data.Format.array = (function() {
    var buildLayers, defaultOptions, format, formatBasicPlot, formatHeatmap, formatPie, formatTimePlot;
    defaultOptions = {
      x: function(d, i) {
        return i;
      },
      y: function(d, i) {
        return d;
      },
      time: function(d, i, startTime) {
        return parseInt(startTime) + parseInt(i);
      },
      type: 'area',
      autoLabels: false,
      labels: [],
      startTime: parseInt(new Date().getTime() / 1000)
    };
    buildLayers = function(data, options, mapFn) {
      var i, result, series;
      result = [];
      if (Epoch.isArray(data[0])) {
        for (i in data) {
          series = data[i];
          result.push(applyLayerLabel({
            values: series.map(mapFn)
          }, options, parseInt(i)));
        }
      } else {
        result.push(applyLayerLabel({
          values: data.map(mapFn)
        }, options, 0));
      }
      return result;
    };
    formatBasicPlot = function(data, options) {
      return buildLayers(data, options, function(d, i) {
        return {
          x: options.x(d, i),
          y: options.y(d, i)
        };
      });
    };
    formatTimePlot = function(data, options) {
      return buildLayers(data, options, function(d, i) {
        return {
          time: options.time(d, i, options.startTime),
          y: options.y(d, i)
        };
      });
    };
    formatHeatmap = function(data, options) {
      return buildLayers(data, options, function(d, i) {
        return {
          time: options.time(d, i, options.startTime),
          histogram: d
        };
      });
    };
    formatPie = function(data, options) {
      var i, result, v;
      result = [];
      for (i in data) {
        v = data[i];
        if (!Epoch.isNumber(data[0])) {
          return [];
        }
        result.push(applyLayerLabel({
          value: v
        }, options, i));
      }
      return result;
    };
    format = function(data, options) {
      var opt;
      if (data == null) {
        data = [];
      }
      if (options == null) {
        options = {};
      }
      if (!(Epoch.isArray(data) && data.length > 0)) {
        return [];
      }
      opt = Epoch.Util.defaults(options, defaultOptions);
      if (opt.type === 'time.heatmap') {
        return formatHeatmap(data, opt);
      } else if (opt.type.match(/^time\./)) {
        return formatTimePlot(data, opt);
      } else if (opt.type === 'pie') {
        return formatPie(data, opt);
      } else {
        return formatBasicPlot(data, opt);
      }
    };
    format.entry = function(datum, options) {
      var d, data, layer, opt, _i, _len, _ref, _results;
      if (options == null) {
        options = {};
      }
      if (options.type === 'time.gauge') {
        if (datum == null) {
          return 0;
        }
        opt = Epoch.Util.defaults(options, defaultOptions);
        d = Epoch.isArray(datum) ? datum[0] : datum;
        return opt.y(d, 0);
      }
      if (datum == null) {
        return [];
      }
      if (options.startTime == null) {
        options.startTime = parseInt(new Date().getTime() / 1000);
      }
      if (Epoch.isArray(datum)) {
        data = datum.map(function(d) {
          return [d];
        });
      } else {
        data = [datum];
      }
      _ref = format(data, options);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push(layer.values[0]);
      }
      return _results;
    };
    return format;
  })();

  Epoch.Data.Format.tuple = (function() {
    var buildLayers, defaultOptions, format;
    defaultOptions = {
      x: function(d, i) {
        return d;
      },
      y: function(d, i) {
        return d;
      },
      time: function(d, i) {
        return d;
      },
      type: 'area',
      autoLabels: false,
      labels: []
    };
    buildLayers = function(data, options, mapFn) {
      var i, result, series;
      if (!Epoch.isArray(data[0])) {
        return [];
      }
      result = [];
      if (Epoch.isArray(data[0][0])) {
        for (i in data) {
          series = data[i];
          result.push(applyLayerLabel({
            values: series.map(mapFn)
          }, options, parseInt(i)));
        }
      } else {
        result.push(applyLayerLabel({
          values: data.map(mapFn)
        }, options, 0));
      }
      return result;
    };
    format = function(data, options) {
      var opt;
      if (data == null) {
        data = [];
      }
      if (options == null) {
        options = {};
      }
      if (!(Epoch.isArray(data) && data.length > 0)) {
        return [];
      }
      opt = Epoch.Util.defaults(options, defaultOptions);
      if (opt.type === 'pie' || opt.type === 'time.heatmap' || opt.type === 'time.gauge') {
        return [];
      } else if (opt.type.match(/^time\./)) {
        return buildLayers(data, opt, function(d, i) {
          return {
            time: opt.time(d[0], parseInt(i)),
            y: opt.y(d[1], parseInt(i))
          };
        });
      } else {
        return buildLayers(data, opt, function(d, i) {
          return {
            x: opt.x(d[0], parseInt(i)),
            y: opt.y(d[1], parseInt(i))
          };
        });
      }
    };
    format.entry = function(datum, options) {
      var data, layer, _i, _len, _ref, _results;
      if (options == null) {
        options = {};
      }
      if (datum == null) {
        return [];
      }
      if (options.startTime == null) {
        options.startTime = parseInt(new Date().getTime() / 1000);
      }
      if (Epoch.isArray(datum) && Epoch.isArray(datum[0])) {
        data = datum.map(function(d) {
          return [d];
        });
      } else {
        data = [datum];
      }
      _ref = format(data, options);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push(layer.values[0]);
      }
      return _results;
    };
    return format;
  })();

  Epoch.Data.Format.keyvalue = (function() {
    var buildLayers, defaultOptions, format, formatBasicPlot, formatTimePlot;
    defaultOptions = {
      type: 'area',
      x: function(d, i) {
        return parseInt(i);
      },
      y: function(d, i) {
        return d;
      },
      time: function(d, i, startTime) {
        return parseInt(startTime) + parseInt(i);
      },
      labels: [],
      autoLabels: false,
      keyLabels: true,
      startTime: parseInt(new Date().getTime() / 1000)
    };
    buildLayers = function(data, keys, options, mapFn) {
      var d, i, j, key, result, values;
      result = [];
      for (j in keys) {
        key = keys[j];
        values = [];
        for (i in data) {
          d = data[i];
          values.push(mapFn(d, key, parseInt(i)));
        }
        result.push(applyLayerLabel({
          values: values
        }, options, parseInt(j), keys));
      }
      return result;
    };
    formatBasicPlot = function(data, keys, options) {
      return buildLayers(data, keys, options, function(d, key, i) {
        var x;
        if (Epoch.isString(options.x)) {
          x = d[options.x];
        } else {
          x = options.x(d, parseInt(i));
        }
        return {
          x: x,
          y: options.y(d[key], parseInt(i))
        };
      });
    };
    formatTimePlot = function(data, keys, options, rangeName) {
      if (rangeName == null) {
        rangeName = 'y';
      }
      return buildLayers(data, keys, options, function(d, key, i) {
        var value;
        if (Epoch.isString(options.time)) {
          value = {
            time: d[options.time]
          };
        } else {
          value = {
            time: options.time(d, parseInt(i), options.startTime)
          };
        }
        value[rangeName] = options.y(d[key], parseInt(i));
        return value;
      });
    };
    format = function(data, keys, options) {
      var opt;
      if (data == null) {
        data = [];
      }
      if (keys == null) {
        keys = [];
      }
      if (options == null) {
        options = {};
      }
      if (!(Epoch.isArray(data) && data.length > 0 && keys.length > 0)) {
        return [];
      }
      opt = Epoch.Util.defaults(options, defaultOptions);
      if (opt.type === 'pie' || opt.type === 'time.gauge') {
        return [];
      } else if (opt.type === 'time.heatmap') {
        return formatTimePlot(data, keys, opt, 'histogram');
      } else if (opt.type.match(/^time\./)) {
        return formatTimePlot(data, keys, opt);
      } else {
        return formatBasicPlot(data, keys, opt);
      }
    };
    format.entry = function(datum, keys, options) {
      var layer, _i, _len, _ref, _results;
      if (keys == null) {
        keys = [];
      }
      if (options == null) {
        options = {};
      }
      if (!((datum != null) && (keys != null) && keys.length > 0)) {
        return [];
      }
      if (options.startTime == null) {
        options.startTime = parseInt(new Date().getTime() / 1000);
      }
      _ref = format([datum], keys, options);
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push(layer.values[0]);
      }
      return _results;
    };
    return format;
  })();

  Epoch.data = function() {
    var args, formatFn, formatter;
    formatter = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if ((formatFn = Epoch.Data.Format[formatter]) == null) {
      return [];
    }
    return formatFn.apply(formatFn, args);
  };

  Epoch.Data.formatData = function(data, type, dataFormat) {
    var a, args, opts, _i, _len, _ref;
    if (data == null) {
      data = [];
    }
    if (!((dataFormat != null) && data.length > 0)) {
      return data;
    }
    if (Epoch.isString(dataFormat)) {
      opts = {
        type: type
      };
      return Epoch.data(dataFormat, data, opts);
    }
    if (!Epoch.isObject(dataFormat)) {
      return data;
    }
    if (!((dataFormat.name != null) && Epoch.isString(dataFormat.name))) {
      return data;
    }
    if (Epoch.Data.Format[dataFormat.name] == null) {
      return data;
    }
    args = [dataFormat.name, data];
    if ((dataFormat["arguments"] != null) && Epoch.isArray(dataFormat["arguments"])) {
      _ref = dataFormat["arguments"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        args.push(a);
      }
    }
    if (dataFormat.options != null) {
      opts = dataFormat.options;
      if (type != null) {
        if (opts.type == null) {
          opts.type = type;
        }
      }
      args.push(opts);
    } else if (type != null) {
      args.push({
        type: type
      });
    }
    return Epoch.data.apply(Epoch.data, args);
  };

  Epoch.Data.formatEntry = function(datum, type, format) {
    var a, args, dataFormat, entry, opts, _i, _len, _ref;
    if (format == null) {
      return datum;
    }
    if (Epoch.isString(format)) {
      opts = {
        type: type
      };
      return Epoch.Data.Format[format].entry(datum, opts);
    }
    if (!Epoch.isObject(format)) {
      return datum;
    }
    if (!((format.name != null) && Epoch.isString(format.name))) {
      return datum;
    }
    if (Epoch.Data.Format[format.name] == null) {
      return datum;
    }
    dataFormat = Epoch.Util.defaults(format, {});
    args = [datum];
    if ((dataFormat["arguments"] != null) && Epoch.isArray(dataFormat["arguments"])) {
      _ref = dataFormat["arguments"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        a = _ref[_i];
        args.push(a);
      }
    }
    if (dataFormat.options != null) {
      opts = dataFormat.options;
      opts.type = type;
      args.push(opts);
    } else if (type != null) {
      args.push({
        type: type
      });
    }
    entry = Epoch.Data.Format[dataFormat.name].entry;
    return entry.apply(entry, args);
  };

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Model = (function(_super) {
    var defaults;

    __extends(Model, _super);

    defaults = {
      dataFormat: null
    };

    function Model(options) {
      if (options == null) {
        options = {};
      }
      Model.__super__.constructor.call(this);
      options = Epoch.Util.defaults(options, defaults);
      this.dataFormat = options.dataFormat;
      this.data = options.data;
      this.loading = false;
    }

    Model.prototype.setData = function(data) {
      this.data = data;
      return this.trigger('data:updated');
    };

    Model.prototype.push = function(entry) {
      this.entry = entry;
      return this.trigger('data:push');
    };

    Model.prototype.hasData = function() {
      return this.data != null;
    };

    Model.prototype.getData = function(type, dataFormat) {
      if (dataFormat == null) {
        dataFormat = this.dataFormat;
      }
      return Epoch.Data.formatData(this.data, type, dataFormat);
    };

    Model.prototype.getNext = function(type, dataFormat) {
      if (dataFormat == null) {
        dataFormat = this.dataFormat;
      }
      return Epoch.Data.formatEntry(this.entry, type, dataFormat);
    };

    return Model;

  })(Epoch.Events);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Plot = (function(_super) {
    var defaultAxisMargins, defaults, optionListeners;

    __extends(Plot, _super);

    defaults = {
      domain: null,
      range: null,
      axes: ['left', 'bottom'],
      ticks: {
        top: 14,
        bottom: 14,
        left: 5,
        right: 5
      },
      tickFormats: {
        top: Epoch.Formats.regular,
        bottom: Epoch.Formats.regular,
        left: Epoch.Formats.si,
        right: Epoch.Formats.si
      }
    };

    defaultAxisMargins = {
      top: 25,
      right: 50,
      bottom: 25,
      left: 50
    };

    optionListeners = {
      'option:margins.top': 'marginsChanged',
      'option:margins.right': 'marginsChanged',
      'option:margins.bottom': 'marginsChanged',
      'option:margins.left': 'marginsChanged',
      'option:axes': 'axesChanged',
      'option:ticks.top': 'ticksChanged',
      'option:ticks.right': 'ticksChanged',
      'option:ticks.bottom': 'ticksChanged',
      'option:ticks.left': 'ticksChanged',
      'option:tickFormats.top': 'tickFormatsChanged',
      'option:tickFormats.right': 'tickFormatsChanged',
      'option:tickFormats.bottom': 'tickFormatsChanged',
      'option:tickFormats.left': 'tickFormatsChanged',
      'option:domain': 'domainChanged',
      'option:range': 'rangeChanged'
    };

    function Plot(options) {
      var givenMargins, pos, _i, _len, _ref;
      this.options = options != null ? options : {};
      givenMargins = Epoch.Util.copy(this.options.margins) || {};
      Plot.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this.margins = {};
      _ref = ['top', 'right', 'bottom', 'left'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        this.margins[pos] = (this.options.margins != null) && (this.options.margins[pos] != null) ? this.options.margins[pos] : this.hasAxis(pos) ? defaultAxisMargins[pos] : 6;
      }
      this.g = this.svg.append("g").attr("transform", "translate(" + this.margins.left + ", " + this.margins.top + ")");
      this.onAll(optionListeners);
    }

    Plot.prototype.setTickFormat = function(axis, fn) {
      return this.options.tickFormats[axis] = fn;
    };

    Plot.prototype.hasAxis = function(axis) {
      return this.options.axes.indexOf(axis) > -1;
    };

    Plot.prototype.innerWidth = function() {
      return this.width - (this.margins.left + this.margins.right);
    };

    Plot.prototype.innerHeight = function() {
      return this.height - (this.margins.top + this.margins.bottom);
    };

    Plot.prototype.x = function() {
      var domain, _ref;
      domain = (_ref = this.options.domain) != null ? _ref : this.extent(function(d) {
        return d.x;
      });
      return d3.scale.linear().domain(domain).range([0, this.innerWidth()]);
    };

    Plot.prototype.y = function() {
      var domain, _ref;
      domain = (_ref = this.options.range) != null ? _ref : this.extent(function(d) {
        return d.y;
      });
      return d3.scale.linear().domain(domain).range([this.innerHeight(), 0]);
    };

    Plot.prototype.bottomAxis = function() {
      return d3.svg.axis().scale(this.x()).orient('bottom').ticks(this.options.ticks.bottom).tickFormat(this.options.tickFormats.bottom);
    };

    Plot.prototype.topAxis = function() {
      return d3.svg.axis().scale(this.x()).orient('top').ticks(this.options.ticks.top).tickFormat(this.options.tickFormats.top);
    };

    Plot.prototype.leftAxis = function() {
      return d3.svg.axis().scale(this.y()).orient('left').ticks(this.options.ticks.left).tickFormat(this.options.tickFormats.left);
    };

    Plot.prototype.rightAxis = function() {
      return d3.svg.axis().scale(this.y()).orient('right').ticks(this.options.ticks.right).tickFormat(this.options.tickFormats.right);
    };

    Plot.prototype.draw = function() {
      if (this._axesDrawn) {
        this._redrawAxes();
      } else {
        this._drawAxes();
      }
      return Plot.__super__.draw.call(this);
    };

    Plot.prototype._redrawAxes = function() {
      if (this.hasAxis('bottom')) {
        this.g.selectAll('.x.axis.bottom').transition().duration(500).ease('linear').call(this.bottomAxis());
      }
      if (this.hasAxis('top')) {
        this.g.selectAll('.x.axis.top').transition().duration(500).ease('linear').call(this.topAxis());
      }
      if (this.hasAxis('left')) {
        this.g.selectAll('.y.axis.left').transition().duration(500).ease('linear').call(this.leftAxis());
      }
      if (this.hasAxis('right')) {
        return this.g.selectAll('.y.axis.right').transition().duration(500).ease('linear').call(this.rightAxis());
      }
    };

    Plot.prototype._drawAxes = function() {
      if (this.hasAxis('bottom')) {
        this.g.append("g").attr("class", "x axis bottom").attr("transform", "translate(0, " + (this.innerHeight()) + ")").call(this.bottomAxis());
      }
      if (this.hasAxis('top')) {
        this.g.append("g").attr('class', 'x axis top').call(this.topAxis());
      }
      if (this.hasAxis('left')) {
        this.g.append("g").attr("class", "y axis left").call(this.leftAxis());
      }
      if (this.hasAxis('right')) {
        this.g.append('g').attr('class', 'y axis right').attr('transform', "translate(" + (this.innerWidth()) + ", 0)").call(this.rightAxis());
      }
      return this._axesDrawn = true;
    };

    Plot.prototype.dimensionsChanged = function() {
      Plot.__super__.dimensionsChanged.call(this);
      this.g.selectAll('.axis').remove();
      this._axesDrawn = false;
      return this.draw();
    };

    Plot.prototype.marginsChanged = function() {
      var pos, size, _ref;
      if (this.options.margins == null) {
        return;
      }
      _ref = this.options.margins;
      for (pos in _ref) {
        size = _ref[pos];
        if (size == null) {
          this.margins[pos] = 6;
        } else {
          this.margins[pos] = size;
        }
      }
      this.g.transition().duration(750).attr("transform", "translate(" + this.margins.left + ", " + this.margins.top + ")");
      return this.draw();
    };

    Plot.prototype.axesChanged = function() {
      var pos, _i, _len, _ref;
      _ref = ['top', 'right', 'bottom', 'left'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        if ((this.options.margins != null) && (this.options.margins[pos] != null)) {
          continue;
        }
        if (this.hasAxis(pos)) {
          this.margins[pos] = defaultAxisMargins[pos];
        } else {
          this.margins[pos] = 6;
        }
      }
      this.g.transition().duration(750).attr("transform", "translate(" + this.margins.left + ", " + this.margins.top + ")");
      this.g.selectAll('.axis').remove();
      this._axesDrawn = false;
      return this.draw();
    };

    Plot.prototype.ticksChanged = function() {
      return this.draw();
    };

    Plot.prototype.tickFormatsChanged = function() {
      return this.draw();
    };

    Plot.prototype.domainChanged = function() {
      return this.draw();
    };

    Plot.prototype.rangeChanged = function() {
      return this.draw();
    };

    return Plot;

  })(Epoch.Chart.SVG);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Area = (function(_super) {
    __extends(Area, _super);

    function Area(options) {
      var _base;
      this.options = options != null ? options : {};
      if ((_base = this.options).type == null) {
        _base.type = 'area';
      }
      Area.__super__.constructor.call(this, this.options);
    }

    Area.prototype.y = function() {
      var a, k, layer, v, _i, _len, _ref, _ref1, _ref2;
      a = [];
      _ref = this.getVisibleLayers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _ref1 = layer.values;
        for (k in _ref1) {
          v = _ref1[k];
          if (a[k] != null) {
            a[k] += v.y;
          }
          if (a[k] == null) {
            a[k] = v.y;
          }
        }
      }
      return d3.scale.linear().domain((_ref2 = this.options.range) != null ? _ref2 : [0, d3.max(a)]).range([this.height - this.margins.top - this.margins.bottom, 0]);
    };

    Area.prototype.draw = function() {
      var area, data, layer, layers, stack, x, y, _ref;
      _ref = [this.x(), this.y(), this.getVisibleLayers()], x = _ref[0], y = _ref[1], layers = _ref[2];
      this.g.selectAll('.layer').remove();
      if (layers.length === 0) {
        return;
      }
      area = d3.svg.area().x(function(d) {
        return x(d.x);
      }).y0(function(d) {
        return y(d.y0);
      }).y1(function(d) {
        return y(d.y0 + d.y);
      });
      stack = d3.layout.stack().values(function(d) {
        return d.values;
      });
      data = stack(layers);
      layer = this.g.selectAll('.layer').data(layers, function(d) {
        return d.category;
      });
      layer.select('.area').attr('d', function(d) {
        return area(d.values);
      });
      layer.enter().append('g').attr('class', function(d) {
        return d.className;
      });
      layer.append('path').attr('class', 'area').attr('d', function(d) {
        return area(d.values);
      });
      return Area.__super__.draw.call(this);
    };

    return Area;

  })(Epoch.Chart.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Bar = (function(_super) {
    var defaults, horizontal_defaults, horizontal_specific, optionListeners;

    __extends(Bar, _super);

    defaults = {
      type: 'bar',
      style: 'grouped',
      orientation: 'vertical',
      padding: {
        bar: 0.08,
        group: 0.1
      },
      outerPadding: {
        bar: 0.08,
        group: 0.1
      }
    };

    horizontal_specific = {
      tickFormats: {
        top: Epoch.Formats.si,
        bottom: Epoch.Formats.si,
        left: Epoch.Formats.regular,
        right: Epoch.Formats.regular
      }
    };

    horizontal_defaults = Epoch.Util.defaults(horizontal_specific, defaults);

    optionListeners = {
      'option:orientation': 'orientationChanged',
      'option:padding': 'paddingChanged',
      'option:outerPadding': 'paddingChanged',
      'option:padding:bar': 'paddingChanged',
      'option:padding:group': 'paddingChanged',
      'option:outerPadding:bar': 'paddingChanged',
      'option:outerPadding:group': 'paddingChanged'
    };

    function Bar(options) {
      this.options = options != null ? options : {};
      if (this.options.orientation === 'horizontal') {
        this.options = Epoch.Util.defaults(this.options, horizontal_defaults);
      } else {
        this.options = Epoch.Util.defaults(this.options, defaults);
      }
      Bar.__super__.constructor.call(this, this.options);
      this.onAll(optionListeners);
    }

    Bar.prototype.x = function() {
      var extent;
      if (this.options.orientation === 'vertical') {
        return d3.scale.ordinal().domain(Epoch.Util.domain(this.getVisibleLayers())).rangeRoundBands([0, this.innerWidth()], this.options.padding.group, this.options.outerPadding.group);
      } else {
        extent = this.extent(function(d) {
          return d.y;
        });
        extent[0] = Math.min(0, extent[0]);
        return d3.scale.linear().domain(extent).range([0, this.width - this.margins.left - this.margins.right]);
      }
    };

    Bar.prototype.x1 = function(x0) {
      var layer;
      return d3.scale.ordinal().domain((function() {
        var _i, _len, _ref, _results;
        _ref = this.getVisibleLayers();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          layer = _ref[_i];
          _results.push(layer.category);
        }
        return _results;
      }).call(this)).rangeRoundBands([0, x0.rangeBand()], this.options.padding.bar, this.options.outerPadding.bar);
    };

    Bar.prototype.y = function() {
      var extent;
      if (this.options.orientation === 'vertical') {
        extent = this.extent(function(d) {
          return d.y;
        });
        extent[0] = Math.min(0, extent[0]);
        return d3.scale.linear().domain(extent).range([this.height - this.margins.top - this.margins.bottom, 0]);
      } else {
        return d3.scale.ordinal().domain(Epoch.Util.domain(this.getVisibleLayers())).rangeRoundBands([0, this.innerHeight()], this.options.padding.group, this.options.outerPadding.group);
      }
    };

    Bar.prototype.y1 = function(y0) {
      var layer;
      return d3.scale.ordinal().domain((function() {
        var _i, _len, _ref, _results;
        _ref = this.getVisibleLayers();
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          layer = _ref[_i];
          _results.push(layer.category);
        }
        return _results;
      }).call(this)).rangeRoundBands([0, y0.rangeBand()], this.options.padding.bar, this.options.outerPadding.bar);
    };

    Bar.prototype._remapData = function() {
      var className, entry, k, layer, map, v, _i, _j, _len, _len1, _name, _ref, _ref1, _results;
      map = {};
      _ref = this.getVisibleLayers();
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        className = 'bar ' + layer.className.replace(/\s*layer\s*/, '');
        _ref1 = layer.values;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          entry = _ref1[_j];
          if (map[_name = entry.x] == null) {
            map[_name] = [];
          }
          map[entry.x].push({
            label: layer.category,
            y: entry.y,
            className: className
          });
        }
      }
      _results = [];
      for (k in map) {
        v = map[k];
        _results.push({
          group: k,
          values: v
        });
      }
      return _results;
    };

    Bar.prototype.draw = function() {
      if (this.options.orientation === 'horizontal') {
        this._drawHorizontal();
      } else {
        this._drawVertical();
      }
      return Bar.__super__.draw.call(this);
    };

    Bar.prototype._drawVertical = function() {
      var data, height, layer, rects, x0, x1, y, _ref;
      _ref = [this.x(), this.y()], x0 = _ref[0], y = _ref[1];
      x1 = this.x1(x0);
      height = this.height - this.margins.top - this.margins.bottom;
      data = this._remapData();
      layer = this.g.selectAll(".layer").data(data, function(d) {
        return d.group;
      });
      layer.transition().duration(750).attr("transform", function(d) {
        return "translate(" + (x0(d.group)) + ", 0)";
      });
      layer.enter().append("g").attr('class', 'layer').attr("transform", function(d) {
        return "translate(" + (x0(d.group)) + ", 0)";
      });
      rects = layer.selectAll('rect').data(function(group) {
        return group.values;
      });
      rects.attr('class', function(d) {
        return d.className;
      });
      rects.transition().duration(600).attr('x', function(d) {
        return x1(d.label);
      }).attr('y', function(d) {
        return y(d.y);
      }).attr('width', x1.rangeBand()).attr('height', function(d) {
        return height - y(d.y);
      });
      rects.enter().append('rect').attr('class', function(d) {
        return d.className;
      }).attr('x', function(d) {
        return x1(d.label);
      }).attr('y', function(d) {
        return y(d.y);
      }).attr('width', x1.rangeBand()).attr('height', function(d) {
        return height - y(d.y);
      });
      rects.exit().transition().duration(150).style('opacity', '0').remove();
      return layer.exit().transition().duration(750).style('opacity', '0').remove();
    };

    Bar.prototype._drawHorizontal = function() {
      var data, layer, rects, width, x, y0, y1, _ref;
      _ref = [this.x(), this.y()], x = _ref[0], y0 = _ref[1];
      y1 = this.y1(y0);
      width = this.width - this.margins.left - this.margins.right;
      data = this._remapData();
      layer = this.g.selectAll(".layer").data(data, function(d) {
        return d.group;
      });
      layer.transition().duration(750).attr("transform", function(d) {
        return "translate(0, " + (y0(d.group)) + ")";
      });
      layer.enter().append("g").attr('class', 'layer').attr("transform", function(d) {
        return "translate(0, " + (y0(d.group)) + ")";
      });
      rects = layer.selectAll('rect').data(function(group) {
        return group.values;
      });
      rects.attr('class', function(d) {
        return d.className;
      });
      rects.transition().duration(600).attr('x', function(d) {
        return 0;
      }).attr('y', function(d) {
        return y1(d.label);
      }).attr('height', y1.rangeBand()).attr('width', function(d) {
        return x(d.y);
      });
      rects.enter().append('rect').attr('class', function(d) {
        return d.className;
      }).attr('x', function(d) {
        return 0;
      }).attr('y', function(d) {
        return y1(d.label);
      }).attr('height', y1.rangeBand()).attr('width', function(d) {
        return x(d.y);
      });
      rects.exit().transition().duration(150).style('opacity', '0').remove();
      return layer.exit().transition().duration(750).style('opacity', '0').remove();
    };

    Bar.prototype.orientationChanged = function() {
      var bottom, left, right, top;
      top = this.options.tickFormats.top;
      bottom = this.options.tickFormats.bottom;
      left = this.options.tickFormats.left;
      right = this.options.tickFormats.right;
      this.options.tickFormats.left = top;
      this.options.tickFormats.right = bottom;
      this.options.tickFormats.top = left;
      this.options.tickFormats.bottom = right;
      return this.draw();
    };

    Bar.prototype.paddingChanged = function() {
      return this.draw();
    };

    return Bar;

  })(Epoch.Chart.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Histogram = (function(_super) {
    var defaults, optionListeners;

    __extends(Histogram, _super);

    defaults = {
      type: 'histogram',
      domain: [0, 100],
      bucketRange: [0, 100],
      buckets: 10,
      cutOutliers: false
    };

    optionListeners = {
      'option:bucketRange': 'bucketRangeChanged',
      'option:buckets': 'bucketsChanged',
      'option:cutOutliers': 'cutOutliersChanged'
    };

    function Histogram(options) {
      this.options = options != null ? options : {};
      Histogram.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this.onAll(optionListeners);
    }

    Histogram.prototype._prepareData = function(data) {
      var bucketSize, buckets, i, index, k, layer, point, prepared, preparedLayer, v, _i, _j, _len, _len1, _ref;
      bucketSize = (this.options.bucketRange[1] - this.options.bucketRange[0]) / this.options.buckets;
      prepared = [];
      for (_i = 0, _len = data.length; _i < _len; _i++) {
        layer = data[_i];
        buckets = (function() {
          var _j, _ref, _results;
          _results = [];
          for (i = _j = 0, _ref = this.options.buckets; 0 <= _ref ? _j < _ref : _j > _ref; i = 0 <= _ref ? ++_j : --_j) {
            _results.push(0);
          }
          return _results;
        }).call(this);
        _ref = layer.values;
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          point = _ref[_j];
          index = parseInt((point.x - this.options.bucketRange[0]) / bucketSize);
          if (this.options.cutOutliers && ((index < 0) || (index >= this.options.buckets))) {
            continue;
          }
          if (index < 0) {
            index = 0;
          } else if (index >= this.options.buckets) {
            index = this.options.buckets - 1;
          }
          buckets[index] += parseInt(point.y);
        }
        preparedLayer = {
          values: buckets.map(function(d, i) {
            return {
              x: parseInt(i) * bucketSize,
              y: d
            };
          })
        };
        for (k in layer) {
          v = layer[k];
          if (k !== 'values') {
            preparedLayer[k] = v;
          }
        }
        prepared.push(preparedLayer);
      }
      return prepared;
    };

    Histogram.prototype.resetData = function() {
      this.setData(this.rawData);
      return this.draw();
    };

    Histogram.prototype.bucketRangeChanged = function() {
      return this.resetData();
    };

    Histogram.prototype.bucketsChanged = function() {
      return this.resetData();
    };

    Histogram.prototype.cutOutliersChanged = function() {
      return this.resetData();
    };

    return Histogram;

  })(Epoch.Chart.Bar);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Line = (function(_super) {
    __extends(Line, _super);

    function Line(options) {
      var _base;
      this.options = options != null ? options : {};
      if ((_base = this.options).type == null) {
        _base.type = 'line';
      }
      Line.__super__.constructor.call(this, this.options);
    }

    Line.prototype.line = function() {
      var x, y, _ref;
      _ref = [this.x(), this.y()], x = _ref[0], y = _ref[1];
      return d3.svg.line().x((function(_this) {
        return function(d) {
          return x(d.x);
        };
      })(this)).y((function(_this) {
        return function(d) {
          return y(d.y);
        };
      })(this));
    };

    Line.prototype.draw = function() {
      var layer, layers, line, x, y, _ref;
      _ref = [this.x(), this.y(), this.line(), this.getVisibleLayers()], x = _ref[0], y = _ref[1], line = _ref[2], layers = _ref[3];
      if (layers.length === 0) {
        return this.g.selectAll('.layer').remove();
      }
      layer = this.g.selectAll('.layer').data(layers, function(d) {
        return d.category;
      });
      layer.select('.line').transition().duration(500).attr('d', function(l) {
        return line(l.values);
      });
      layer.enter().append('g').attr('class', function(l) {
        return l.className;
      }).append('path').attr('class', 'line').attr('d', function(l) {
        return line(l.values);
      });
      layer.exit().transition().duration(750).style('opacity', '0').remove();
      return Line.__super__.draw.call(this);
    };

    return Line;

  })(Epoch.Chart.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Pie = (function(_super) {
    var defaults;

    __extends(Pie, _super);

    defaults = {
      type: 'pie',
      margin: 10,
      inner: 0
    };

    function Pie(options) {
      this.options = options != null ? options : {};
      Pie.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this.pie = d3.layout.pie().sort(null).value(function(d) {
        return d.value;
      });
      this.arc = d3.svg.arc().outerRadius((function(_this) {
        return function() {
          return (Math.max(_this.width, _this.height) / 2) - _this.options.margin;
        };
      })(this)).innerRadius((function(_this) {
        return function() {
          return _this.options.inner;
        };
      })(this));
      this.g = this.svg.append('g').attr("transform", "translate(" + (this.width / 2) + ", " + (this.height / 2) + ")");
      this.on('option:margin', 'marginChanged');
      this.on('option:inner', 'innerChanged');
    }

    Pie.prototype.draw = function() {
      var arcs, path, text;
      this.g.selectAll('.arc').remove();
      arcs = this.g.selectAll(".arc").data(this.pie(this.getVisibleLayers()), function(d) {
        return d.data.category;
      });
      arcs.enter().append('g').attr('class', function(d) {
        return "arc pie " + d.data.className;
      });
      arcs.select('path').attr('d', this.arc);
      arcs.select('text').attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + (_this.arc.centroid(d)) + ")";
        };
      })(this)).text(function(d) {
        return d.data.label || d.data.category;
      });
      path = arcs.append("path").attr("d", this.arc).each(function(d) {
        return this._current = d;
      });
      text = arcs.append("text").attr("transform", (function(_this) {
        return function(d) {
          return "translate(" + (_this.arc.centroid(d)) + ")";
        };
      })(this)).attr("dy", ".35em").style("text-anchor", "middle").text(function(d) {
        return d.data.label || d.data.category;
      });
      return Pie.__super__.draw.call(this);
    };

    Pie.prototype.marginChanged = function() {
      return this.draw();
    };

    Pie.prototype.innerChanged = function() {
      return this.draw();
    };

    return Pie;

  })(Epoch.Chart.SVG);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Chart.Scatter = (function(_super) {
    var defaults;

    __extends(Scatter, _super);

    defaults = {
      type: 'scatter',
      radius: 3.5,
      axes: ['top', 'bottom', 'left', 'right']
    };

    function Scatter(options) {
      this.options = options != null ? options : {};
      Scatter.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this.on('option:radius', 'radiusChanged');
    }

    Scatter.prototype.draw = function() {
      var dots, layer, layers, radius, x, y, _ref;
      _ref = [this.x(), this.y(), this.getVisibleLayers()], x = _ref[0], y = _ref[1], layers = _ref[2];
      radius = this.options.radius;
      if (layers.length === 0) {
        return this.g.selectAll('.layer').remove();
      }
      layer = this.g.selectAll('.layer').data(layers, function(d) {
        return d.category;
      });
      layer.enter().append('g').attr('class', function(d) {
        return d.className;
      });
      dots = layer.selectAll('.dot').data(function(l) {
        return l.values;
      });
      dots.transition().duration(500).attr("r", function(d) {
        var _ref1;
        return (_ref1 = d.r) != null ? _ref1 : radius;
      }).attr("cx", function(d) {
        return x(d.x);
      }).attr("cy", function(d) {
        return y(d.y);
      });
      dots.enter().append('circle').attr('class', 'dot').attr("r", function(d) {
        var _ref1;
        return (_ref1 = d.r) != null ? _ref1 : radius;
      }).attr("cx", function(d) {
        return x(d.x);
      }).attr("cy", function(d) {
        return y(d.y);
      });
      dots.exit().transition().duration(750).style('opacity', 0).remove();
      layer.exit().transition().duration(750).style('opacity', 0).remove();
      return Scatter.__super__.draw.call(this);
    };

    Scatter.prototype.radiusChanged = function() {
      return this.draw();
    };

    return Scatter;

  })(Epoch.Chart.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Plot = (function(_super) {
    var defaultAxisMargins, defaults, optionListeners;

    __extends(Plot, _super);

    defaults = {
      fps: 24,
      historySize: 120,
      windowSize: 40,
      queueSize: 10,
      axes: ['bottom'],
      ticks: {
        time: 15,
        left: 5,
        right: 5
      },
      tickFormats: {
        top: Epoch.Formats.seconds,
        bottom: Epoch.Formats.seconds,
        left: Epoch.Formats.si,
        right: Epoch.Formats.si
      }
    };

    defaultAxisMargins = {
      top: 25,
      right: 50,
      bottom: 25,
      left: 50
    };

    optionListeners = {
      'option:margins': 'marginsChanged',
      'option:margins.top': 'marginsChanged',
      'option:margins.right': 'marginsChanged',
      'option:margins.bottom': 'marginsChanged',
      'option:margins.left': 'marginsChanged',
      'option:axes': 'axesChanged',
      'option:ticks': 'ticksChanged',
      'option:ticks.top': 'ticksChanged',
      'option:ticks.right': 'ticksChanged',
      'option:ticks.bottom': 'ticksChanged',
      'option:ticks.left': 'ticksChanged',
      'option:tickFormats': 'tickFormatsChanged',
      'option:tickFormats.top': 'tickFormatsChanged',
      'option:tickFormats.right': 'tickFormatsChanged',
      'option:tickFormats.bottom': 'tickFormatsChanged',
      'option:tickFormats.left': 'tickFormatsChanged'
    };

    function Plot(options) {
      var givenMargins, pos, _i, _len, _ref;
      this.options = options;
      givenMargins = Epoch.Util.copy(this.options.margins) || {};
      Plot.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      if (this.options.model) {
        this.options.model.on('data:push', (function(_this) {
          return function() {
            return _this.pushFromModel();
          };
        })(this));
      }
      this._queue = [];
      this.margins = {};
      _ref = ['top', 'right', 'bottom', 'left'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        this.margins[pos] = (this.options.margins != null) && (this.options.margins[pos] != null) ? this.options.margins[pos] : this.hasAxis(pos) ? defaultAxisMargins[pos] : 6;
      }
      this.svg = this.el.insert('svg', ':first-child').attr('width', this.width).attr('height', this.height).style('z-index', '1000');
      if (this.el.style('position') !== 'absolute' && this.el.style('position') !== 'relative') {
        this.el.style('position', 'relative');
      }
      this.canvas.style({
        position: 'absolute',
        'z-index': '999'
      });
      this._sizeCanvas();
      this.animation = {
        interval: null,
        active: false,
        delta: (function(_this) {
          return function() {
            return -(_this.w() / _this.options.fps);
          };
        })(this),
        tickDelta: (function(_this) {
          return function() {
            return -((_this.w() / _this.pixelRatio) / _this.options.fps);
          };
        })(this),
        frame: 0,
        duration: this.options.fps
      };
      this._buildAxes();
      this.animationCallback = (function(_this) {
        return function() {
          return _this._animate();
        };
      })(this);
      this.onAll(optionListeners);
    }

    Plot.prototype._sizeCanvas = function() {
      this.canvas.attr({
        width: this.innerWidth(),
        height: this.innerHeight()
      });
      return this.canvas.style({
        width: "" + (this.innerWidth() / this.pixelRatio) + "px",
        height: "" + (this.innerHeight() / this.pixelRatio) + "px",
        top: "" + this.margins.top + "px",
        left: "" + this.margins.left + "px"
      });
    };

    Plot.prototype._buildAxes = function() {
      this.svg.selectAll('.axis').remove();
      this._prepareTimeAxes();
      return this._prepareRangeAxes();
    };

    Plot.prototype._annotateLayers = function(prepared) {
      var classes, copy, data, i, layer, start;
      data = [];
      for (i in prepared) {
        layer = prepared[i];
        copy = Epoch.Util.copy(layer);
        start = Math.max(0, layer.values.length - this.options.historySize);
        copy.values = layer.values.slice(start);
        classes = ['layer'];
        classes.push("category" + ((i | 0) + 1));
        if (layer.label != null) {
          classes.push(Epoch.Util.dasherize(layer.label));
        }
        copy.className = classes.join(' ');
        copy.visible = true;
        data.push(copy);
      }
      return data;
    };

    Plot.prototype._offsetX = function() {
      return 0;
    };

    Plot.prototype._prepareTimeAxes = function() {
      var axis;
      if (this.hasAxis('bottom')) {
        axis = this.bottomAxis = this.svg.append('g').attr('class', "x axis bottom canvas").attr('transform', "translate(" + (this.margins.left - 1) + ", " + (this.innerHeight() / this.pixelRatio + this.margins.top) + ")");
        axis.append('path').attr('class', 'domain').attr('d', "M0,0H" + (this.innerWidth() / this.pixelRatio + 1));
      }
      if (this.hasAxis('top')) {
        axis = this.topAxis = this.svg.append('g').attr('class', "x axis top canvas").attr('transform', "translate(" + (this.margins.left - 1) + ", " + this.margins.top + ")");
        axis.append('path').attr('class', 'domain').attr('d', "M0,0H" + (this.innerWidth() / this.pixelRatio + 1));
      }
      return this._resetInitialTimeTicks();
    };

    Plot.prototype._resetInitialTimeTicks = function() {
      var i, k, layer, tickInterval, _i, _len, _ref, _ref1, _results;
      tickInterval = this.options.ticks.time;
      this._ticks = [];
      this._tickTimer = tickInterval;
      if (this.bottomAxis != null) {
        this.bottomAxis.selectAll('.tick').remove();
      }
      if (this.topAxis != null) {
        this.topAxis.selectAll('.tick').remove();
      }
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (!((layer.values != null) && layer.values.length > 0)) {
          continue;
        }
        _ref1 = [this.options.windowSize - 1, layer.values.length - 1], i = _ref1[0], k = _ref1[1];
        while (i >= 0 && k >= 0) {
          this._pushTick(i, layer.values[k].time, false, true);
          i -= tickInterval;
          k -= tickInterval;
        }
        break;
      }
      return _results;
    };

    Plot.prototype._prepareRangeAxes = function() {
      if (this.hasAxis('left')) {
        this.svg.append("g").attr("class", "y axis left").attr('transform', "translate(" + (this.margins.left - 1) + ", " + this.margins.top + ")").call(this.leftAxis());
      }
      if (this.hasAxis('right')) {
        return this.svg.append('g').attr('class', 'y axis right').attr('transform', "translate(" + (this.width - this.margins.right) + ", " + this.margins.top + ")").call(this.rightAxis());
      }
    };

    Plot.prototype.leftAxis = function() {
      var axis, ticks;
      ticks = this.options.ticks.left;
      axis = d3.svg.axis().scale(this.ySvg()).orient('left').tickFormat(this.options.tickFormats.left);
      if (ticks === 2) {
        return axis.tickValues(this.extent(function(d) {
          return d.y;
        }));
      } else {
        return axis.ticks(ticks);
      }
    };

    Plot.prototype.rightAxis = function() {
      var axis, extent, ticks;
      extent = this.extent(function(d) {
        return d.y;
      });
      ticks = this.options.ticks.right;
      axis = d3.svg.axis().scale(this.ySvg()).orient('right').tickFormat(this.options.tickFormats.left);
      if (ticks === 2) {
        return axis.tickValues(this.extent(function(d) {
          return d.y;
        }));
      } else {
        return axis.ticks(ticks);
      }
    };

    Plot.prototype.hasAxis = function(name) {
      return this.options.axes.indexOf(name) > -1;
    };

    Plot.prototype.innerWidth = function() {
      return (this.width - (this.margins.left + this.margins.right)) * this.pixelRatio;
    };

    Plot.prototype.innerHeight = function() {
      return (this.height - (this.margins.top + this.margins.bottom)) * this.pixelRatio;
    };

    Plot.prototype._prepareEntry = function(entry) {
      return entry;
    };

    Plot.prototype._prepareLayers = function(layers) {
      return layers;
    };

    Plot.prototype._startTransition = function() {
      if (this.animation.active === true || this._queue.length === 0) {
        return;
      }
      this.trigger('transition:start');
      this._shift();
      this.animation.active = true;
      return this.animation.interval = setInterval(this.animationCallback, 1000 / this.options.fps);
    };

    Plot.prototype._stopTransition = function() {
      var firstTick, lastTick, layer, _i, _len, _ref, _ref1;
      if (!this.inTransition()) {
        return;
      }
      _ref = this.data;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        if (!(layer.values.length > this.options.windowSize + 1)) {
          continue;
        }
        layer.values.shift();
      }
      _ref1 = [this._ticks[0], this._ticks[this._ticks.length - 1]], firstTick = _ref1[0], lastTick = _ref1[1];
      if ((lastTick != null) && lastTick.enter) {
        lastTick.enter = false;
        lastTick.opacity = 1;
      }
      if ((firstTick != null) && firstTick.exit) {
        this._shiftTick();
      }
      this.animation.frame = 0;
      this.trigger('transition:end');
      if (this._queue.length > 0) {
        return this._shift();
      } else {
        this.animation.active = false;
        return clearInterval(this.animation.interval);
      }
    };

    Plot.prototype.inTransition = function() {
      return this.animation.active;
    };

    Plot.prototype.push = function(layers) {
      layers = this._prepareLayers(layers);
      if (this._queue.length > this.options.queueSize) {
        this._queue.splice(this.options.queueSize, this._queue.length - this.options.queueSize);
      }
      if (this._queue.length === this.options.queueSize) {
        return false;
      }
      this._queue.push(layers.map((function(_this) {
        return function(entry) {
          return _this._prepareEntry(entry);
        };
      })(this)));
      this.trigger('push');
      if (!this.inTransition()) {
        return this._startTransition();
      }
    };

    Plot.prototype.pushFromModel = function() {
      return this.push(this.options.model.getNext(this.options.type, this.options.dataFormat));
    };

    Plot.prototype._shift = function() {
      var entry, i, layer, _ref;
      this.trigger('before:shift');
      entry = this._queue.shift();
      _ref = this.data;
      for (i in _ref) {
        layer = _ref[i];
        layer.values.push(entry[i]);
      }
      this._updateTicks(entry[0].time);
      this._transitionRangeAxes();
      return this.trigger('after:shift');
    };

    Plot.prototype._transitionRangeAxes = function() {
      if (this.hasAxis('left')) {
        this.svg.selectAll('.y.axis.left').transition().duration(500).ease('linear').call(this.leftAxis());
      }
      if (this.hasAxis('right')) {
        return this.svg.selectAll('.y.axis.right').transition().duration(500).ease('linear').call(this.rightAxis());
      }
    };

    Plot.prototype._animate = function() {
      if (!this.inTransition()) {
        return;
      }
      if (++this.animation.frame === this.animation.duration) {
        this._stopTransition();
      }
      this.draw(this.animation.frame * this.animation.delta());
      return this._updateTimeAxes();
    };

    Plot.prototype.y = function() {
      return d3.scale.linear().domain(this.extent(function(d) {
        return d.y;
      })).range([this.innerHeight(), 0]);
    };

    Plot.prototype.ySvg = function() {
      return d3.scale.linear().domain(this.extent(function(d) {
        return d.y;
      })).range([this.innerHeight() / this.pixelRatio, 0]);
    };

    Plot.prototype.w = function() {
      return this.innerWidth() / this.options.windowSize;
    };

    Plot.prototype._updateTicks = function(newTime) {
      if (!(this.hasAxis('top') || this.hasAxis('bottom'))) {
        return;
      }
      if (!((++this._tickTimer) % this.options.ticks.time)) {
        this._pushTick(this.options.windowSize, newTime, true);
      }
      if (!(this._ticks[0].x - (this.w() / this.pixelRatio) >= 0)) {
        return this._ticks[0].exit = true;
      }
    };

    Plot.prototype._pushTick = function(bucket, time, enter, reverse) {
      var g, tick;
      if (enter == null) {
        enter = false;
      }
      if (reverse == null) {
        reverse = false;
      }
      if (!(this.hasAxis('top') || this.hasAxis('bottom'))) {
        return;
      }
      tick = {
        time: time,
        x: bucket * (this.w() / this.pixelRatio) + this._offsetX(),
        opacity: enter ? 0 : 1,
        enter: enter ? true : false,
        exit: false
      };
      if (this.hasAxis('bottom')) {
        g = this.bottomAxis.append('g').attr('class', 'tick major').attr('transform', "translate(" + (tick.x + 1) + ",0)").style('opacity', tick.opacity);
        g.append('line').attr('y2', 6);
        g.append('text').attr('text-anchor', 'middle').attr('dy', 19).text(this.options.tickFormats.bottom(tick.time));
        tick.bottomEl = g;
      }
      if (this.hasAxis('top')) {
        g = this.topAxis.append('g').attr('class', 'tick major').attr('transform', "translate(" + (tick.x + 1) + ",0)").style('opacity', tick.opacity);
        g.append('line').attr('y2', -6);
        g.append('text').attr('text-anchor', 'middle').attr('dy', -10).text(this.options.tickFormats.top(tick.time));
        tick.topEl = g;
      }
      if (reverse) {
        this._ticks.unshift(tick);
      } else {
        this._ticks.push(tick);
      }
      return tick;
    };

    Plot.prototype._shiftTick = function() {
      var tick;
      if (!(this._ticks.length > 0)) {
        return;
      }
      tick = this._ticks.shift();
      if (tick.topEl != null) {
        tick.topEl.remove();
      }
      if (tick.bottomEl != null) {
        return tick.bottomEl.remove();
      }
    };

    Plot.prototype._updateTimeAxes = function() {
      var dop, dx, tick, _i, _len, _ref, _ref1, _results;
      if (!(this.hasAxis('top') || this.hasAxis('bottom'))) {
        return;
      }
      _ref = [this.animation.tickDelta(), 1 / this.options.fps], dx = _ref[0], dop = _ref[1];
      _ref1 = this._ticks;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        tick = _ref1[_i];
        tick.x += dx;
        if (this.hasAxis('bottom')) {
          tick.bottomEl.attr('transform', "translate(" + (tick.x + 1) + ",0)");
        }
        if (this.hasAxis('top')) {
          tick.topEl.attr('transform', "translate(" + (tick.x + 1) + ",0)");
        }
        if (tick.enter) {
          tick.opacity += dop;
        } else if (tick.exit) {
          tick.opacity -= dop;
        }
        if (tick.enter || tick.exit) {
          if (this.hasAxis('bottom')) {
            tick.bottomEl.style('opacity', tick.opacity);
          }
          if (this.hasAxis('top')) {
            _results.push(tick.topEl.style('opacity', tick.opacity));
          } else {
            _results.push(void 0);
          }
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Plot.prototype.draw = function(delta) {
      if (delta == null) {
        delta = 0;
      }
      return Plot.__super__.draw.call(this);
    };

    Plot.prototype.dimensionsChanged = function() {
      Plot.__super__.dimensionsChanged.call(this);
      this.svg.attr('width', this.width).attr('height', this.height);
      this._sizeCanvas();
      this._buildAxes();
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Plot.prototype.axesChanged = function() {
      var pos, _i, _len, _ref;
      _ref = ['top', 'right', 'bottom', 'left'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        pos = _ref[_i];
        if ((this.options.margins != null) && (this.options.margins[pos] != null)) {
          continue;
        }
        if (this.hasAxis(pos)) {
          this.margins[pos] = defaultAxisMargins[pos];
        } else {
          this.margins[pos] = 6;
        }
      }
      this._sizeCanvas();
      this._buildAxes();
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Plot.prototype.ticksChanged = function() {
      this._resetInitialTimeTicks();
      this._transitionRangeAxes();
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Plot.prototype.tickFormatsChanged = function() {
      this._resetInitialTimeTicks();
      this._transitionRangeAxes();
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Plot.prototype.marginsChanged = function() {
      var pos, size, _ref;
      if (this.options.margins == null) {
        return;
      }
      _ref = this.options.margins;
      for (pos in _ref) {
        size = _ref[pos];
        if (size == null) {
          this.margins[pos] = 6;
        } else {
          this.margins[pos] = size;
        }
      }
      this._sizeCanvas();
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Plot.prototype.layerChanged = function() {
      this._transitionRangeAxes();
      return Plot.__super__.layerChanged.call(this);
    };

    return Plot;

  })(Epoch.Chart.Canvas);

  Epoch.Time.Stack = (function(_super) {
    __extends(Stack, _super);

    function Stack() {
      return Stack.__super__.constructor.apply(this, arguments);
    }

    Stack.prototype._stackLayers = function() {
      var i, layer, layers, y0, _i, _ref, _results;
      if (!((layers = this.getVisibleLayers()).length > 0)) {
        return;
      }
      _results = [];
      for (i = _i = 0, _ref = layers[0].values.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        y0 = 0;
        _results.push((function() {
          var _j, _len, _results1;
          _results1 = [];
          for (_j = 0, _len = layers.length; _j < _len; _j++) {
            layer = layers[_j];
            layer.values[i].y0 = y0;
            _results1.push(y0 += layer.values[i].y);
          }
          return _results1;
        })());
      }
      return _results;
    };

    Stack.prototype._prepareLayers = function(layers) {
      var d, i, y0;
      y0 = 0;
      for (i in layers) {
        d = layers[i];
        if (!this.data[i].visible) {
          continue;
        }
        d.y0 = y0;
        y0 += d.y;
      }
      return layers;
    };

    Stack.prototype.setData = function(data) {
      Stack.__super__.setData.call(this, data);
      return this._stackLayers();
    };

    Stack.prototype.extent = function() {
      var i, j, layers, max, sum, _i, _j, _ref, _ref1, _ref2;
      _ref = [0, this.getVisibleLayers()], max = _ref[0], layers = _ref[1];
      if (!layers.length) {
        return [0, 0];
      }
      for (i = _i = 0, _ref1 = layers[0].values.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        sum = 0;
        for (j = _j = 0, _ref2 = layers.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; j = 0 <= _ref2 ? ++_j : --_j) {
          sum += layers[j].values[i].y;
        }
        if (sum > max) {
          max = sum;
        }
      }
      return [0, max];
    };

    Stack.prototype.layerChanged = function() {
      var layers, _i, _len, _ref;
      this._stackLayers();
      _ref = this._queue;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layers = _ref[_i];
        this._prepareLayers(layers);
      }
      return Stack.__super__.layerChanged.call(this);
    };

    return Stack;

  })(Epoch.Time.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Area = (function(_super) {
    __extends(Area, _super);

    function Area(options) {
      var _base;
      this.options = options != null ? options : {};
      if ((_base = this.options).type == null) {
        _base.type = 'time.area';
      }
      Area.__super__.constructor.call(this, this.options);
    }

    Area.prototype.setStyles = function(layer) {
      var styles;
      if (layer.className != null) {
        styles = this.getStyles("g." + (layer.className.replace(/\s/g, '.')) + " path.area");
      } else {
        styles = this.getStyles("g path.area");
      }
      this.ctx.fillStyle = styles.fill;
      if (styles.stroke != null) {
        this.ctx.strokeStyle = styles.stroke;
      }
      if (styles['stroke-width'] != null) {
        return this.ctx.lineWidth = styles['stroke-width'].replace('px', '');
      }
    };

    Area.prototype._drawAreas = function(delta) {
      var args, borderX, entry, firstX, i, j, k, layer, layers, trans, w, y, _i, _ref, _ref1, _ref2, _results;
      if (delta == null) {
        delta = 0;
      }
      _ref = [this.y(), this.w(), this.getVisibleLayers()], y = _ref[0], w = _ref[1], layers = _ref[2];
      _results = [];
      for (i = _i = _ref1 = layers.length - 1; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {
        layer = layers[i];
        this.setStyles(layer);
        this.ctx.beginPath();
        _ref2 = [this.options.windowSize, layer.values.length, this.inTransition()], j = _ref2[0], k = _ref2[1], trans = _ref2[2];
        firstX = null;
        while ((--j >= -2) && (--k >= 0)) {
          entry = layer.values[k];
          args = [(j + 1) * w + delta, y(entry.y + entry.y0)];
          if (trans) {
            args[0] += w;
          }
          if (i === this.options.windowSize - 1) {
            this.ctx.moveTo.apply(this.ctx, args);
          } else {
            this.ctx.lineTo.apply(this.ctx, args);
          }
        }
        if (trans) {
          borderX = (j + 3) * w + delta;
        } else {
          borderX = (j + 2) * w + delta;
        }
        this.ctx.lineTo(borderX, this.innerHeight());
        this.ctx.lineTo(this.width * this.pixelRatio + w + delta, this.innerHeight());
        this.ctx.closePath();
        _results.push(this.ctx.fill());
      }
      return _results;
    };

    Area.prototype._drawStrokes = function(delta) {
      var args, entry, firstX, i, k, layer, layers, trans, w, y, _i, _ref, _ref1, _ref2, _results;
      if (delta == null) {
        delta = 0;
      }
      _ref = [this.y(), this.w(), this.getVisibleLayers()], y = _ref[0], w = _ref[1], layers = _ref[2];
      _results = [];
      for (i = _i = _ref1 = layers.length - 1; _ref1 <= 0 ? _i <= 0 : _i >= 0; i = _ref1 <= 0 ? ++_i : --_i) {
        layer = layers[i];
        this.setStyles(layer);
        this.ctx.beginPath();
        _ref2 = [this.options.windowSize, layer.values.length, this.inTransition()], i = _ref2[0], k = _ref2[1], trans = _ref2[2];
        firstX = null;
        while ((--i >= -2) && (--k >= 0)) {
          entry = layer.values[k];
          args = [(i + 1) * w + delta, y(entry.y + entry.y0)];
          if (trans) {
            args[0] += w;
          }
          if (i === this.options.windowSize - 1) {
            this.ctx.moveTo.apply(this.ctx, args);
          } else {
            this.ctx.lineTo.apply(this.ctx, args);
          }
        }
        _results.push(this.ctx.stroke());
      }
      return _results;
    };

    Area.prototype.draw = function(delta) {
      if (delta == null) {
        delta = 0;
      }
      this.clear();
      this._drawAreas(delta);
      this._drawStrokes(delta);
      return Area.__super__.draw.call(this);
    };

    return Area;

  })(Epoch.Time.Stack);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Bar = (function(_super) {
    __extends(Bar, _super);

    function Bar(options) {
      var _base;
      this.options = options != null ? options : {};
      if ((_base = this.options).type == null) {
        _base.type = 'time.bar';
      }
      Bar.__super__.constructor.call(this, this.options);
    }

    Bar.prototype._offsetX = function() {
      return 0.5 * this.w() / this.pixelRatio;
    };

    Bar.prototype.setStyles = function(className) {
      var styles;
      styles = this.getStyles("rect.bar." + (className.replace(/\s/g, '.')));
      this.ctx.fillStyle = styles.fill;
      if ((styles.stroke == null) || styles.stroke === 'none') {
        this.ctx.strokeStyle = 'transparent';
      } else {
        this.ctx.strokeStyle = styles.stroke;
      }
      if (styles['stroke-width'] != null) {
        return this.ctx.lineWidth = styles['stroke-width'].replace('px', '');
      }
    };

    Bar.prototype.draw = function(delta) {
      var args, entry, ex, ey, ey0, i, iBoundry, k, layer, trans, w, y, _i, _len, _ref, _ref1, _ref2, _ref3;
      if (delta == null) {
        delta = 0;
      }
      this.clear();
      _ref = [this.y(), this.w()], y = _ref[0], w = _ref[1];
      _ref1 = this.getVisibleLayers();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        layer = _ref1[_i];
        if (!(layer.values.length > 0)) {
          continue;
        }
        this.setStyles(layer.className);
        _ref2 = [this.options.windowSize, layer.values.length, this.inTransition()], i = _ref2[0], k = _ref2[1], trans = _ref2[2];
        iBoundry = trans ? -1 : 0;
        while ((--i >= iBoundry) && (--k >= 0)) {
          entry = layer.values[k];
          _ref3 = [i * w + delta, entry.y, entry.y0], ex = _ref3[0], ey = _ref3[1], ey0 = _ref3[2];
          if (trans) {
            ex += w;
          }
          args = [ex + 1, y(ey + ey0), w - 2, this.innerHeight() - y(ey) + 0.5 * this.pixelRatio];
          this.ctx.fillRect.apply(this.ctx, args);
          this.ctx.strokeRect.apply(this.ctx, args);
        }
      }
      return Bar.__super__.draw.call(this);
    };

    return Bar;

  })(Epoch.Time.Stack);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Gauge = (function(_super) {
    var defaults, optionListeners;

    __extends(Gauge, _super);

    defaults = {
      type: 'time.gauge',
      domain: [0, 1],
      ticks: 10,
      tickSize: 5,
      tickOffset: 5,
      fps: 34,
      format: Epoch.Formats.percent
    };

    optionListeners = {
      'option:domain': 'domainChanged',
      'option:ticks': 'ticksChanged',
      'option:tickSize': 'tickSizeChanged',
      'option:tickOffset': 'tickOffsetChanged',
      'option:format': 'formatChanged'
    };

    function Gauge(options) {
      this.options = options != null ? options : {};
      Gauge.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this.value = this.options.value || 0;
      if (this.options.model) {
        this.options.model.on('data:push', (function(_this) {
          return function() {
            return _this.pushFromModel();
          };
        })(this));
      }
      if (this.el.style('position') !== 'absolute' && this.el.style('position') !== 'relative') {
        this.el.style('position', 'relative');
      }
      this.svg = this.el.insert('svg', ':first-child').attr('width', this.width).attr('height', this.height).attr('class', 'gauge-labels');
      this.svg.style({
        'position': 'absolute',
        'z-index': '1'
      });
      this.svg.append('g').attr('transform', "translate(" + (this.textX()) + ", " + (this.textY()) + ")").append('text').attr('class', 'value').text(this.options.format(this.value));
      this.animation = {
        interval: null,
        active: false,
        delta: 0,
        target: 0
      };
      this._animate = (function(_this) {
        return function() {
          if (Math.abs(_this.animation.target - _this.value) < Math.abs(_this.animation.delta)) {
            _this.value = _this.animation.target;
            clearInterval(_this.animation.interval);
            _this.animation.active = false;
          } else {
            _this.value += _this.animation.delta;
          }
          _this.svg.select('text.value').text(_this.options.format(_this.value));
          return _this.draw();
        };
      })(this);
      this.onAll(optionListeners);
    }

    Gauge.prototype.update = function(value) {
      this.animation.target = value;
      this.animation.delta = (value - this.value) / this.options.fps;
      if (!this.animation.active) {
        this.animation.interval = setInterval(this._animate, 1000 / this.options.fps);
        return this.animation.active = true;
      }
    };

    Gauge.prototype.push = function(value) {
      return this.update(value);
    };

    Gauge.prototype.pushFromModel = function() {
      var next;
      next = this.options.model.getNext(this.options.type, this.options.dataFormat);
      return this.update(next);
    };

    Gauge.prototype.radius = function() {
      return this.getHeight() / 1.58;
    };

    Gauge.prototype.centerX = function() {
      return this.getWidth() / 2;
    };

    Gauge.prototype.centerY = function() {
      return 0.68 * this.getHeight();
    };

    Gauge.prototype.textX = function() {
      return this.width / 2;
    };

    Gauge.prototype.textY = function() {
      return 0.48 * this.height;
    };

    Gauge.prototype.getAngle = function(value) {
      var a, b, _ref;
      _ref = this.options.domain, a = _ref[0], b = _ref[1];
      return ((value - a) / (b - a)) * (Math.PI + 2 * Math.PI / 8) - Math.PI / 2 - Math.PI / 8;
    };

    Gauge.prototype.setStyles = function(selector) {
      var styles;
      styles = this.getStyles(selector);
      this.ctx.fillStyle = styles.fill;
      this.ctx.strokeStyle = styles.stroke;
      if (styles['stroke-width'] != null) {
        return this.ctx.lineWidth = styles['stroke-width'].replace('px', '');
      }
    };

    Gauge.prototype.draw = function() {
      var a, c, cx, cy, i, r, s, t, tickOffset, tickSize, x1, x2, y1, y2, _i, _ref, _ref1, _ref2, _ref3;
      _ref = [this.centerX(), this.centerY(), this.radius()], cx = _ref[0], cy = _ref[1], r = _ref[2];
      _ref1 = [this.options.tickOffset, this.options.tickSize], tickOffset = _ref1[0], tickSize = _ref1[1];
      this.clear();
      t = d3.scale.linear().domain([0, this.options.ticks]).range([-(9 / 8) * Math.PI, Math.PI / 8]);
      this.setStyles('.epoch .gauge .tick');
      this.ctx.beginPath();
      for (i = _i = 0, _ref2 = this.options.ticks; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = 0 <= _ref2 ? ++_i : --_i) {
        a = t(i);
        _ref3 = [Math.cos(a), Math.sin(a)], c = _ref3[0], s = _ref3[1];
        x1 = c * (r - tickOffset) + cx;
        y1 = s * (r - tickOffset) + cy;
        x2 = c * (r - tickOffset - tickSize) + cx;
        y2 = s * (r - tickOffset - tickSize) + cy;
        this.ctx.moveTo(x1, y1);
        this.ctx.lineTo(x2, y2);
      }
      this.ctx.stroke();
      this.setStyles('.epoch .gauge .arc.outer');
      this.ctx.beginPath();
      this.ctx.arc(cx, cy, r, -(9 / 8) * Math.PI, (1 / 8) * Math.PI, false);
      this.ctx.stroke();
      this.setStyles('.epoch .gauge .arc.inner');
      this.ctx.beginPath();
      this.ctx.arc(cx, cy, r - 10, -(9 / 8) * Math.PI, (1 / 8) * Math.PI, false);
      this.ctx.stroke();
      this.drawNeedle();
      return Gauge.__super__.draw.call(this);
    };

    Gauge.prototype.drawNeedle = function() {
      var cx, cy, r, ratio, _ref;
      _ref = [this.centerX(), this.centerY(), this.radius()], cx = _ref[0], cy = _ref[1], r = _ref[2];
      ratio = this.value / this.options.domain[1];
      this.setStyles('.epoch .gauge .needle');
      this.ctx.beginPath();
      this.ctx.save();
      this.ctx.translate(cx, cy);
      this.ctx.rotate(this.getAngle(this.value));
      this.ctx.moveTo(4 * this.pixelRatio, 0);
      this.ctx.lineTo(-4 * this.pixelRatio, 0);
      this.ctx.lineTo(-1 * this.pixelRatio, 19 - r);
      this.ctx.lineTo(1, 19 - r);
      this.ctx.fill();
      this.setStyles('.epoch .gauge .needle-base');
      this.ctx.beginPath();
      this.ctx.arc(0, 0, this.getWidth() / 25, 0, 2 * Math.PI);
      this.ctx.fill();
      return this.ctx.restore();
    };

    Gauge.prototype.domainChanged = function() {
      return this.draw();
    };

    Gauge.prototype.ticksChanged = function() {
      return this.draw();
    };

    Gauge.prototype.tickSizeChanged = function() {
      return this.draw();
    };

    Gauge.prototype.tickOffsetChanged = function() {
      return this.draw();
    };

    Gauge.prototype.formatChanged = function() {
      return this.svg.select('text.value').text(this.options.format(this.value));
    };

    return Gauge;

  })(Epoch.Chart.Canvas);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Heatmap = (function(_super) {
    var colorFunctions, defaults, optionListeners;

    __extends(Heatmap, _super);

    defaults = {
      type: 'time.heatmap',
      buckets: 10,
      bucketRange: [0, 100],
      opacity: 'linear',
      bucketPadding: 2,
      paintZeroValues: false,
      cutOutliers: false
    };

    colorFunctions = {
      root: function(value, max) {
        return Math.pow(value / max, 0.5);
      },
      linear: function(value, max) {
        return value / max;
      },
      quadratic: function(value, max) {
        return Math.pow(value / max, 2);
      },
      cubic: function(value, max) {
        return Math.pow(value / max, 3);
      },
      quartic: function(value, max) {
        return Math.pow(value / max, 4);
      },
      quintic: function(value, max) {
        return Math.pow(value / max, 5);
      }
    };

    optionListeners = {
      'option:buckets': 'bucketsChanged',
      'option:bucketRange': 'bucketRangeChanged',
      'option:opacity': 'opacityChanged',
      'option:bucketPadding': 'bucketPaddingChanged',
      'option:paintZeroValues': 'paintZeroValuesChanged',
      'option:cutOutliers': 'cutOutliersChanged'
    };

    function Heatmap(options) {
      this.options = options != null ? options : {};
      Heatmap.__super__.constructor.call(this, this.options = Epoch.Util.defaults(this.options, defaults));
      this._setOpacityFunction();
      this._setupPaintCanvas();
      this.onAll(optionListeners);
    }

    Heatmap.prototype._setOpacityFunction = function() {
      if (Epoch.isString(this.options.opacity)) {
        this._opacityFn = colorFunctions[this.options.opacity];
        if (this._opacityFn == null) {
          return Epoch.exception("Unknown coloring function provided '" + this.options.opacity + "'");
        }
      } else if (Epoch.isFunction(this.options.opacity)) {
        return this._opacityFn = this.options.opacity;
      } else {
        return Epoch.exception("Unknown type for provided coloring function.");
      }
    };

    Heatmap.prototype.setData = function(data) {
      var layer, _i, _len, _ref, _results;
      Heatmap.__super__.setData.call(this, data);
      _ref = this.data;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push(layer.values = layer.values.map((function(_this) {
          return function(entry) {
            return _this._prepareEntry(entry);
          };
        })(this)));
      }
      return _results;
    };

    Heatmap.prototype._getBuckets = function(entry) {
      var bucketSize, count, i, index, prepared, value, _i, _ref, _ref1;
      prepared = {
        time: entry.time,
        max: 0,
        buckets: (function() {
          var _i, _ref, _results;
          _results = [];
          for (i = _i = 0, _ref = this.options.buckets; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
            _results.push(0);
          }
          return _results;
        }).call(this)
      };
      bucketSize = (this.options.bucketRange[1] - this.options.bucketRange[0]) / this.options.buckets;
      _ref = entry.histogram;
      for (value in _ref) {
        count = _ref[value];
        index = parseInt((value - this.options.bucketRange[0]) / bucketSize);
        if (this.options.cutOutliers && ((index < 0) || (index >= this.options.buckets))) {
          continue;
        }
        if (index < 0) {
          index = 0;
        } else if (index >= this.options.buckets) {
          index = this.options.buckets - 1;
        }
        prepared.buckets[index] += parseInt(count);
      }
      for (i = _i = 0, _ref1 = prepared.buckets.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        prepared.max = Math.max(prepared.max, prepared.buckets[i]);
      }
      return prepared;
    };

    Heatmap.prototype.y = function() {
      return d3.scale.linear().domain(this.options.bucketRange).range([this.innerHeight(), 0]);
    };

    Heatmap.prototype.ySvg = function() {
      return d3.scale.linear().domain(this.options.bucketRange).range([this.innerHeight() / this.pixelRatio, 0]);
    };

    Heatmap.prototype.h = function() {
      return this.innerHeight() / this.options.buckets;
    };

    Heatmap.prototype._offsetX = function() {
      return 0.5 * this.w() / this.pixelRatio;
    };

    Heatmap.prototype._setupPaintCanvas = function() {
      this.paintWidth = (this.options.windowSize + 1) * this.w();
      this.paintHeight = this.height * this.pixelRatio;
      this.paint = document.createElement('CANVAS');
      this.paint.width = this.paintWidth;
      this.paint.height = this.paintHeight;
      this.p = Epoch.Util.getContext(this.paint);
      this.redraw();
      this.on('after:shift', '_paintEntry');
      this.on('transition:end', '_shiftPaintCanvas');
      return this.on('transition:end', (function(_this) {
        return function() {
          return _this.draw(_this.animation.frame * _this.animation.delta());
        };
      })(this));
    };

    Heatmap.prototype.redraw = function() {
      var drawColumn, entryIndex;
      if (!(Epoch.isArray(this.data) && this.data.length > 0 && this.data[0].length > 0)) {
        return;
      }
      entryIndex = this.data[0].values.length;
      drawColumn = this.options.windowSize;
      if (this.inTransition()) {
        drawColumn++;
      }
      while ((--entryIndex >= 0) && (--drawColumn >= 0)) {
        this._paintEntry(entryIndex, drawColumn);
      }
      return this.draw(this.animation.frame * this.animation.delta());
    };

    Heatmap.prototype._computeColor = function(value, max, color) {
      return Epoch.Util.toRGBA(color, this._opacityFn(value, max));
    };

    Heatmap.prototype._paintEntry = function(entryIndex, drawColumn) {
      var bucket, bucketTotals, color, count, entries, entry, h, i, j, layer, max, maxTotal, styles, sum, w, xPos, _i, _j, _len, _len1, _ref, _ref1, _ref2, _results;
      if (entryIndex == null) {
        entryIndex = null;
      }
      if (drawColumn == null) {
        drawColumn = null;
      }
      _ref = [this.w(), this.h()], w = _ref[0], h = _ref[1];
      if (entryIndex == null) {
        entryIndex = this.data[0].values.length - 1;
      }
      if (drawColumn == null) {
        drawColumn = this.options.windowSize;
      }
      entries = [];
      bucketTotals = (function() {
        var _i, _ref1, _results;
        _results = [];
        for (i = _i = 0, _ref1 = this.options.buckets; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
          _results.push(0);
        }
        return _results;
      }).call(this);
      maxTotal = 0;
      _ref1 = this.getVisibleLayers();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        layer = _ref1[_i];
        entry = this._getBuckets(layer.values[entryIndex]);
        _ref2 = entry.buckets;
        for (bucket in _ref2) {
          count = _ref2[bucket];
          bucketTotals[bucket] += count;
        }
        maxTotal += entry.max;
        styles = this.getStyles("." + (layer.className.split(' ').join('.')) + " rect.bucket");
        entry.color = styles.fill;
        entries.push(entry);
      }
      xPos = drawColumn * w;
      this.p.clearRect(xPos, 0, w, this.paintHeight);
      j = this.options.buckets;
      _results = [];
      for (bucket in bucketTotals) {
        sum = bucketTotals[bucket];
        color = this._avgLab(entries, bucket);
        max = 0;
        for (_j = 0, _len1 = entries.length; _j < _len1; _j++) {
          entry = entries[_j];
          max += (entry.buckets[bucket] / sum) * maxTotal;
        }
        if (sum > 0 || this.options.paintZeroValues) {
          this.p.fillStyle = this._computeColor(sum, max, color);
          this.p.fillRect(xPos, (j - 1) * h, w - this.options.bucketPadding, h - this.options.bucketPadding);
        }
        _results.push(j--);
      }
      return _results;
    };

    Heatmap.prototype._shiftPaintCanvas = function() {
      var data;
      data = this.p.getImageData(this.w(), 0, this.paintWidth - this.w(), this.paintHeight);
      return this.p.putImageData(data, 0, 0);
    };

    Heatmap.prototype._avgLab = function(entries, bucket) {
      var a, b, color, entry, i, l, ratio, total, value, _i, _len, _ref;
      _ref = [0, 0, 0, 0], l = _ref[0], a = _ref[1], b = _ref[2], total = _ref[3];
      for (_i = 0, _len = entries.length; _i < _len; _i++) {
        entry = entries[_i];
        if (entry.buckets[bucket] == null) {
          continue;
        }
        total += entry.buckets[bucket];
      }
      for (i in entries) {
        entry = entries[i];
        if (entry.buckets[bucket] != null) {
          value = entry.buckets[bucket] | 0;
        } else {
          value = 0;
        }
        ratio = value / total;
        color = d3.lab(entry.color);
        l += ratio * color.l;
        a += ratio * color.a;
        b += ratio * color.b;
      }
      return d3.lab(l, a, b).toString();
    };

    Heatmap.prototype.draw = function(delta) {
      if (delta == null) {
        delta = 0;
      }
      this.clear();
      this.ctx.drawImage(this.paint, delta, 0);
      return Heatmap.__super__.draw.call(this);
    };

    Heatmap.prototype.bucketsChanged = function() {
      return this.redraw();
    };

    Heatmap.prototype.bucketRangeChanged = function() {
      this._transitionRangeAxes();
      return this.redraw();
    };

    Heatmap.prototype.opacityChanged = function() {
      this._setOpacityFunction();
      return this.redraw();
    };

    Heatmap.prototype.bucketPaddingChanged = function() {
      return this.redraw();
    };

    Heatmap.prototype.paintZeroValuesChanged = function() {
      return this.redraw();
    };

    Heatmap.prototype.cutOutliersChanged = function() {
      return this.redraw();
    };

    Heatmap.prototype.layerChanged = function() {
      return this.redraw();
    };

    return Heatmap;

  })(Epoch.Time.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Epoch.Time.Line = (function(_super) {
    __extends(Line, _super);

    function Line(options) {
      var _base;
      this.options = options != null ? options : {};
      if ((_base = this.options).type == null) {
        _base.type = 'time.line';
      }
      Line.__super__.constructor.call(this, this.options);
    }

    Line.prototype.setStyles = function(className) {
      var styles;
      styles = this.getStyles("g." + (className.replace(/\s/g, '.')) + " path.line");
      this.ctx.fillStyle = styles.fill;
      this.ctx.strokeStyle = styles.stroke;
      return this.ctx.lineWidth = this.pixelRatio * styles['stroke-width'].replace('px', '');
    };

    Line.prototype.y = function() {
      return d3.scale.linear().domain(this.extent(function(d) {
        return d.y;
      })).range([this.innerHeight() - this.pixelRatio / 2, this.pixelRatio]);
    };

    Line.prototype.draw = function(delta) {
      var args, entry, i, k, layer, trans, w, y, _i, _len, _ref, _ref1, _ref2;
      if (delta == null) {
        delta = 0;
      }
      this.clear();
      _ref = [this.y(), this.w()], y = _ref[0], w = _ref[1];
      _ref1 = this.getVisibleLayers();
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        layer = _ref1[_i];
        if (!(layer.values.length > 0)) {
          continue;
        }
        this.setStyles(layer.className);
        this.ctx.beginPath();
        _ref2 = [this.options.windowSize, layer.values.length, this.inTransition()], i = _ref2[0], k = _ref2[1], trans = _ref2[2];
        while ((--i >= -2) && (--k >= 0)) {
          entry = layer.values[k];
          args = [(i + 1) * w + delta, y(entry.y)];
          if (trans) {
            args[0] += w;
          }
          if (i === this.options.windowSize - 1) {
            this.ctx.moveTo.apply(this.ctx, args);
          } else {
            this.ctx.lineTo.apply(this.ctx, args);
          }
        }
        this.ctx.stroke();
      }
      return Line.__super__.draw.call(this);
    };

    return Line;

  })(Epoch.Time.Plot);

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  Epoch._typeMap = {
    'area': Epoch.Chart.Area,
    'bar': Epoch.Chart.Bar,
    'line': Epoch.Chart.Line,
    'pie': Epoch.Chart.Pie,
    'scatter': Epoch.Chart.Scatter,
    'histogram': Epoch.Chart.Histogram,
    'time.area': Epoch.Time.Area,
    'time.bar': Epoch.Time.Bar,
    'time.line': Epoch.Time.Line,
    'time.gauge': Epoch.Time.Gauge,
    'time.heatmap': Epoch.Time.Heatmap
  };

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var MooToolsModule;

  MooToolsModule = function() {
    var DATA_NAME;
    DATA_NAME = 'epoch-chart';
    return Element.implement('epoch', function(options) {
      var chart, klass, self;
      self = $$(this);
      if ((chart = self.retrieve(DATA_NAME)[0]) == null) {
        options.el = this;
        klass = Epoch._typeMap[options.type];
        if (klass == null) {
          Epoch.exception("Unknown chart type '" + options.type + "'");
        }
        self.store(DATA_NAME, (chart = new klass(options)));
        chart.draw();
      }
      return chart;
    });
  };

  if (window.MooTools != null) {
    MooToolsModule();
  }

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var jQueryModule;

  jQueryModule = function($) {
    var DATA_NAME;
    DATA_NAME = 'epoch-chart';
    return $.fn.epoch = function(options) {
      var chart, klass;
      options.el = this.get(0);
      if ((chart = this.data(DATA_NAME)) == null) {
        klass = Epoch._typeMap[options.type];
        if (klass == null) {
          Epoch.exception("Unknown chart type '" + options.type + "'");
        }
        this.data(DATA_NAME, (chart = new klass(options)));
        chart.draw();
      }
      return chart;
    };
  };

  if (window.jQuery != null) {
    jQueryModule(jQuery);
  }

}).call(this);
// Generated by CoffeeScript 1.8.0
(function() {
  var zeptoModule;

  zeptoModule = function($) {
    var DATA_NAME, chartId, chartMap, next_cid;
    DATA_NAME = 'epoch-chart';
    chartMap = {};
    chartId = 0;
    next_cid = function() {
      return "" + DATA_NAME + "-" + (++chartId);
    };
    return $.extend($.fn, {
      epoch: function(options) {
        var chart, cid, klass;
        if ((cid = this.data(DATA_NAME)) != null) {
          return chartMap[cid];
        }
        options.el = this.get(0);
        klass = Epoch._typeMap[options.type];
        if (klass == null) {
          Epoch.exception("Unknown chart type '" + options.type + "'");
        }
        this.data(DATA_NAME, (cid = next_cid()));
        chart = new klass(options);
        chartMap[cid] = chart;
        chart.draw();
        return chart;
      }
    });
  };

  if (window.Zepto != null) {
    zeptoModule(Zepto);
  }

}).call(this);
